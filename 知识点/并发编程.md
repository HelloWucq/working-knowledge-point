#一.volatile：处理可见性问题
##1.实现原则：Lock前缀指令会引起处理器缓存回写到内存；一个处理器的缓存回写到内存会导致其他处理器的缓存无效
#二.synchronized
##1.三种形式：对于普通同步方法，锁是当前实例对象；对于静态同步方法，锁是当前类的Class对象；对于同步代码块，锁是Synchonized括号里配置的对象
##2.偏向锁：同一个线程多次获得锁不存在竞争,在锁竞争激烈的情况下，可以禁用偏向锁
##3.轻量级锁：
##4.自旋锁：

#三.Java的内存模型
##1.线程通信机制：共享内存和消息传递
##2.线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，JMM决定一个线程对共享变量的写入何时对另一个线程可见
##3.指令重排序(编译器优化，指令级并行，内存系统)
###3.1.happens-before
###3.2.数据依赖性
###3.3.AS-IF-SERIAL语义


#四.Java中的锁
##1.Lock:
##2.队列同步器（AbstractQueuedSynchronizer）:模板方法模式
###2.1.同步队列（FIFO双向队列）
###2.2.独占式同步状态获取与释放
###2.3.共享式同步状态获取与释放
###2.4.独占式超时获取同步状态



##3.重入锁
###3.1.线程再次获取锁；锁的最终释放
###3.2.公平锁与非公平锁

##4.读写锁

##5.Condition接口

##6.锁优化（减小锁持有时间；减小锁粒度；锁分离；锁粗化）

##7.无锁化（CAS操作）[http://www.cnblogs.com/Mainz/p/3556430.html](http://www.cnblogs.com/Mainz/p/3556430.html "CAS")

##8.CAS操作：ABA问题；循环时间长开销大；只能保证一个共享变量的原子操作

#五.Java并发容器
##1.ConcurrentHashMap
##2.ConcurrentLinkedQueue
##3.阻塞队列BlockingQueue
##4.Fork/Join框架




#六.Java中的并发工具类
##1.CountDownLatch:允许一个或多个线程等待其他线程完成操作
##2.同步屏障CyclicBarrier：让一组线程到达一个屏障时被阻塞，知道最后一个线程到达屏障，屏障才会开门
##3.Semaphore(信号量)：控制同时访问特定资源的线程数量
##4.Exchanger（线程间交换数据）


#七.Java中的线程池
##1.降低资源消耗；提高响应速度；提高线程的可管理性
##2.如果当前线程运行的线程数少于corePoolSize创建新线程执行任务；如果运行的线程等于或多于corePoolSize将任务加到BlockingQueue;如果无法将任务加入到BlockingQueue创建新的线程处理任务；如果创建新线程将是当前运行的线程超出maximumPoolSize任务将被拒绝


#八.Executor框架
##1.应用程序通过Executor框架控制上层的调度；而下层的调度由操作系统内核控制
##2.ThreadPoolExecutor(SingleThreadExecutor、FixedThreadPool、CachedThreadPool)
##3.ScheduledThreadPoolExecutor
##4.Future接口
##5.Runnable接口与Callable接口
##6.FutureTask



#九.补充
##1.无状态对象永远是线程安全的
##2.不可变对象永远是线程安全的

#十.高并发环境下的限流策略
##10.1.高并发环境下防止系统过载的方法：缓存、降级、限流
###10.1.1.缓存：提升系统访问速度和增大系统的吞吐量
###10.1.2.降级：通过配置降级开关，实现对流程的控制；前置化降级开关， 基于 OpenResty+配置中心实现降级；业务降低，比如在大促的时候，会优先保证核心业务的流程可用
###10.1.3.限流（资源+策略）：漏桶算法；令牌桶算法

#十一.线程安全性问题
##11.1.对象的发布与逸出
- 发布(publish) 使对象能够在当前作用域之外的代码中使用
- 逸出(escape) 当某个不应该发布的对象被发布了
###11.1.1.逸出
- 静态域逸出
- public修饰的get方法
- 方法参数传递
- 隐式的this
###11.1.2.安全发布对象
- 在静态域中直接初始化
- 对应的引用保存到volatile或者AtomicReferance引用中
- 由final修饰
- 由锁来保护


#十二.J.U.C并发包
##12.1.juc-locks 锁框架
##12.1.1.接口
###12.2.1.Lock接口
    Lock lock = ...;
	if (lock.tryLock()) {
    	try {
       	 // manipulate protected state
    	} finally {
        	lock.unlock();
    	}
	} else {
    	// perform alternative actions
	}
###12.2.2.Condition接口：当线程执行condition对象的await方法时，当前线程会立即释放锁，并进入对象的等待区，等待其它线程唤醒或中断。
- 等待 Condition 时，为了防止发生“虚假唤醒”， Condition 一般都是在一个循环中被等待，并测试正被等待的状态声明，
###12.2.3.ReadWriteLock接口
##12.1.2.常用类
###12.3.1.ReentrantLock类：可重入的独占锁


- 直接实现Lock接口


    public class ReentrantLock extends Object implements Lock,Serializable


- 使用方式

    class X {
    	private final ReentrantLock lock = new ReentrantLock();
    	// ...
    	public void m() {
       	 	lock.lock(); // block until condition holds
       	 	try {
            // ... method body
       	 	} finally {
            lock.unlock();
       	 	}
    	}
	}
- 原理：通过内部类实现AQS框架
- 公平策略原理（AQS的独占功能）
- 非公平策略原理
##12.1.3.AQS
### 针对的问题
- 资源是可以被同时访问？还是在同一时间只能被一个线程访问？（共享/独占功能）
- 访问资源的线程如何进行并发管理？（等待队列）
- 如果线程等不及资源了，如何从等待队列退出？（超时/中断）
###1.框架：维护了一个volatile in state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞是会进入此队列）
###2.资源共享，自定义同步器
- isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。
- tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。
- tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。
- tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源
- tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。
###3.源码详解
####3.1.acquire(int)
     public final void acquire(int arg) {
     if (!tryAcquire(arg) &&
         acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
         selfInterrupt();
 	 }
- tryAcquire()尝试直接去获取资源，如果成功则直接返回；

    	protected boolean tryAcquire(int arg) {
         	throw new UnsupportedOperationException();
    	}
- addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；

    	private Node addWaiter(Node mode) {
   	 	//以给定模式构造结点。mode有两种：EXCLUSIVE（独占）和SHARED（共享）
    		Node node = new Node(Thread.currentThread(), mode);
    
    		//尝试快速方式直接放到队尾。
   			Node pred = tail;
    		if (pred != null) {
        		node.prev = pred;
        		if (compareAndSetTail(pred, node)) 	{
            		pred.next = node;
            		return node;
        		}
    		}
    
    		//上一步失败则通过enq入队。
    		enq(node);
    		return node;
		}


		private Node enq(final Node node) {
   	 		//CAS"自旋"，直到成功加入队尾
    		for (;;) {
        		Node t = tail;
        		if (t == null) { // 队列为空，创建一个空的标志结点作为head结点，并将tail也指向它。
            		if (compareAndSetHead(new Node()))
       	         		tail = head;
        		} else {//正常流程，放入队尾
            		node.prev = t;
            		if (compareAndSetTail(t, node)) 	{
               	 		t.next = node;
                		return t;
            		}
	        	}
	    	}
		}
- acquireQueued()使线程在等待队列中获取资源，一直获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/acquireQueued()%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png)
1. 结点进入队尾后，检查状态，找到安全休息点；
2. 调用park()进入waiting状态，等待unpark()或interrupt()唤醒自己；
3. 被唤醒后，看自己是不是有资格能拿到号。如果拿到，head指向当前结点，并返回从入队到拿到号的整个过程中是否被中断过；如果没拿到，继续流程1。

			final boolean acquireQueued(final Node node, int arg) {
    			boolean failed = true;//标记是否成功拿到资源
    			try {
        			boolean interrupted = false;//标记等待过程中是否被中断过
        
        		//又是一个“自旋”！
        			for (;;) {
            			final Node p = node.predecessor();//拿到前驱
            			//如果前驱是head，即该结点已成老二，那么便有资格去尝试获取资源（可能是老大释放完资源唤醒自己的，当然也可能被interrupt了）。
           				 if (p == head && tryAcquire(arg)) {
                			setHead(node);//拿到资源后，将head指向该结点。所以head所指的标杆结点，就是当前获取到资源的那个结点或null。
                			p.next = null; // setHead中node.prev已置为null，此处再将head.next置为null，就是为了方便GC回收以前的head结点。也就意味着之前拿完资源的结点出队了！
                			failed = false;
                			return interrupted;//返回等待过程中是否被中断过
            		}
            
            			//如果自己可以休息了，就进入waiting状态，直到被unpark()
            		if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                		interrupted = true;//如果等待过程中被中断过，哪怕只有那么一次，就将interrupted标记为true
        		}
    		} finally {
        		if (failed)
	            	cancelAcquire(node);
	    	}
		}
			private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
    			int ws = pred.waitStatus;//拿到前驱的状态
    			if (ws == Node.SIGNAL)
        		//如果已经告诉前驱拿完号后通知自己一下，那就可以安心休息了
        			return true;
    			if (ws > 0) {
        			/*
         			* 如果前驱放弃了，那就一直往前找，直到找到最近一个正常等待的状态，并排在它的后边。
         			* 注意：那些放弃的结点，由于被自己“加塞”到它们前边，它们相当于形成一个无引用链，稍后就会被保安大叔赶走了(GC回收)！
         			*/
        			do {
           				 node.prev = pred = pred.prev;
        			} while (pred.waitStatus > 0);
        		pred.next = node;
    			} else {
         			//如果前驱正常，那就把前驱的状态设置成SIGNAL，告诉它拿完号后通知自己一下。有可能失败，人家说不定刚刚释放完呢！
        			compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
    			}
    		return false;
		}

		private final boolean parkAndCheckInterrupt() {
     		LockSupport.park(this);//调用park()使线程进入waiting状态
		     return Thread.interrupted();//如果被唤醒，查看自己是不是被中断的。
		 }
- 如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。
###3.2.release(int)
    public final boolean release(int arg) {
    	if (tryRelease(arg)) {
        	Node h = head;//找到头结点
        	if (h != null && h.waitStatus != 0)
            	unparkSuccessor(h);//唤醒等待队列里的下一个线程
        	return true;
    	}
    	return false;
	}
- tryRelease(int):尝试去释放指定量的资源

			protected boolean tryRelease(int arg) {
     			throw new UnsupportedOperationException();
 			}
- unparkSuccessor(Node)

    	private void unparkSuccessor(Node node) {
    		//这里，node一般为当前线程所在的结点。
    		int ws = node.waitStatus;
    		if (ws < 0)//置零当前线程所在的结点状态，允许失败。
        		compareAndSetWaitStatus(node, ws, 0);

    		Node s = node.next;//找到下一个需要唤醒的结点s
    		if (s == null || s.waitStatus > 0) {//如果为空或已取消
        		s = null;
        		for (Node t = tail; t != null && t != node; t = t.prev)
            		if (t.waitStatus <= 0)//从这里可以看出，<=0的结点，都是还有效的结点。
                		s = t;
    		}
    		if (s != null)
        		LockSupport.unpark(s.thread);//唤醒
		}
###3.3.acquireShared(int)
- tryAcquireShared()尝试获取资源，成功则直接返回；
- 失败则通过doAcquireShared()进入等待队列，直到获取到资源为止才返回。

     	public final void acquireShared(int arg) {
     		if (tryAcquireShared(arg) < 0)
         		doAcquireShared(arg);
		}
- doAcquireShared(int)

    	private void doAcquireShared(int arg) {
    		final Node node = addWaiter(Node.SHARED);//加入队列尾部
    		boolean failed = true;//是否成功标志
    		try {
        		boolean interrupted = false;//等待过程中是否被中断过的标志
        		for (;;) {
            		final Node p = node.predecessor();//前驱
            		if (p == head) {//如果到head的下一个，因为head是拿到资源的线程，此时node被唤醒，很可能是head用完资源来唤醒自己的
                	int r = tryAcquireShared(arg);//尝试获取资源
                	if (r >= 0) {//成功
                    	setHeadAndPropagate(node, r);//将head指向自己，还有剩余资源可以再唤醒之后的线程
                    	p.next = null; // help GC
                    	if (interrupted)//如果等待过程中被打断过，此时将中断补上。
	                       	selfInterrupt();
	                    failed = false;
                    	return;
                	}
            	}
            
            	//判断状态，寻找安全点，进入waiting状态，等着被unpark()或interrupt()
            	if (shouldParkAfterFailedAcquire(p, node) &&
                	parkAndCheckInterrupt())
                	interrupted = true;
        		}
    		} finally {
        		if (failed)
           	 		cancelAcquire(node);
    		}
		}
- setHeadAndPropagate(Node, int)

    	private void setHeadAndPropagate(Node node, int propagate) {
    		Node h = head; 
    		setHead(node);//head指向自己
     		//如果还有剩余量，继续唤醒下一个邻居线程
    		if (propagate > 0 || h == null || h.waitStatus < 0) {
        		Node s = node.next;
        		if (s == null || s.isShared())
           		 	doReleaseShared();
    		}
		}
###3.4.releaseShared():释放掉资源后，唤醒后继
    public final boolean releaseShared(int arg) {
    	if (tryReleaseShared(arg)) {//尝试释放资源
        	doReleaseShared();//唤醒后继结点
        	return true;
    	}
    	return false;
	}
- doReleaseShared()

    	private void doReleaseShared() {
    		for (;;) {
        		Node h = head;
        		if (h != null && h != tail) {
            		int ws = h.waitStatus;
            		if (ws == Node.SIGNAL) {
                		if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                    	continue;
                	unparkSuccessor(h);//唤醒后继
            		}
            		else if (ws == 0 &&
                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                		continue;
        			}
        			if (h == head)// head发生变化
            			break;
    		}
		}









##12.2.juc-atomic 原子类框架(CAS操作)
##12.3.juc-sync 同步器框架
###12.3.1.CountDownLatch:倒数计数器，构造时设定计数值，当计数值归零后，所有阻塞线程恢复执行；其内部实现了AQS框架
###12.3.2.CyclicBarrier:循环栅栏，构造时设定等待线程数，当所有线程都到达栅栏后，栅栏放行；其内部通过ReentrantLock和Condition实现同步
###12.3.3.Semaphore:信号量，类似于“令牌”，用于控制共享资源的访问数量；其内部实现了AQS框架
###12.3.4.Exchanger:交换器，类似于双向栅栏，用于线程之间的配对和数据交换；其内部根据并发情况有“单槽交换”和“多槽交换”之分
###12.3.5.Phaser:多阶段栅栏，相当于CyclicBarrier的升级版，可用于分阶段任务的并发控制执行；其内部比较复杂，支持树形结构，以减少并发带来的竞争


##12.4.juc-collections 集合框架
###12.4.1.ConcurrenHashMap
###12.4.2.CopyOnWriteArrayList
###12.4.3.ConcurrentLinkedQueue
###12.4.4.BlockingQueue
###12.4.5.SynchronousQueue
###12.4.6.LinkedTransferQueue


##12.5.juc-executors 执行器框架
###12.5.1.线程池
###12.5.2.Future模式
###12.5.3.Fork/Join框架