#一.内存区域（可见性、原子性、有序性）
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/Java%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png)
##1.程序计数器：当前线程所执行的字节码的行号指示器，没有OutOfMemoryError情况
##2.Java虚拟机栈：线程私有，描述Java方法执行的内存模型；每个方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口
###2.1.局部变量表：编译期可知的各种基本数据类型、对象引用、和returnAddress类型
###2.2.栈帧
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/%E6%A0%88%E5%B8%A7%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png)
###2.3.操作数栈：用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间
###2.4.帧数据区:访问常量池的指针，方便程序访问常量池
##3.本地方法栈：为虚拟机中使用Native方法服务
##4.Java堆：几乎所有的对象实例都在此分配
##5.方法区：存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
###5.1.如果系统使用了动态代理，运行时可能产生大量的类，需要设置一个合理的永久区大小
##6.运行时常量池：方法区的一部分
##7.直接内存


#二.内存布局
##1.对象头（Mark Word、类型指针）、实力数据和对齐填充
##2.句柄和直接指针



#三.对象是否“存活”
##1.引用计数算法：
##2.可达性分析算法：GC Roots(虚拟机栈中引用的对象；方法区中类静态属性引用对象；方法区中常量引用的对象；本地方法栈中JNI引用的对象)

#四.引用
##1.强引用：new出来的对象
##2.软引用：一些还有用但非必须的对象
##3.弱引用：描述非必需对象，只能生存到下一次垃圾收集发生之前
##4.虚引用：这个对象被收集器回收时收到一个系统通知


#五.垃圾收集算法
##1.标记-清除算法（效率问题；空间问题（内存碎片））
##2.复制算法（新生代回收算法（Eden空间以及两块较小的Survivor空间））
##3.标记-整理算法
##4.分代收集算法

#六.垃圾收集器
##1.Serial收集器
##2.ParNew收集器
##3.Parrallel Scavenge收集器（达到一个可控制的吞吐量（CPU用于运行用户代码的时间与CPU总消耗的时间比值））
##4.Serial Old收集器
##5.Parallel Old收集器
##6.CMS收集器（获取最短回收停顿时间）
##7.G1收集器

#七.内存分配与回收策略
##1.对象优先在Eden分配（当Eden区没有足够空间进行分配时，虚拟机将发生一次Minor GC）
##2.大对象直接进入老年代（很长的字符串以及数组）
##3.长期存活的对象将进入老年代
##4.动态对象年龄判定
##5.空间分配担保

#垃圾收集器
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png)

#八.JDK监控与故障处理工具
##1.jps显示指定系统内所有的虚拟机进程
##2.jstat用于收集虚拟机各方面的运行数据
##3.jinfo.显示虚拟机配置信息
##4.jmap生成虚拟机的内存转储快照
##5.jhat用于分析heapdump文件
##6.jstack显示虚拟机的线程快照



#九.配置参数的设置
##1.最大堆和初始化堆的设置
##2.新生代的设置：一般设置为整个堆空间的1/3到1/4左右
##3.堆溢出处理：
##4.方法区的配置：
##5.栈配置：
##6.直接内存配置：直接内存适合申请次数较少、访问较频繁的场合
##7.工作模式的选择

#十.Java堆
##1.处理线程过多导致的OOM(1.合理减少线程总数；2.减少最大堆空间；3.减少线程的栈空间)
##2.永久区溢出（1.增加MaxPermSize的值；2.减少系统需要的类的数量；3.使用ClassLoader合理装载各个类，并定期进行回收）
##3.GC效率低下引起的OOM



#十一.Class文件
##1.魔术：class文件的标志
##2.版本号
##3.常量池：
##4.Class的访问标志（两个字节）：表明类的访问信息
##5.当前类、父类和接口
##6.Class文件的字段
##7.Class文件的方法基本结构
##8.方法的执行主体-Code属性
##9.记录行号：
##10.保存局部变量和参数
##11.加快字节码校验


#十二.Class装载系统
##1.加载、连接（验证、准备、解析）、初始化
##2.ClassLoader(启动类加载器；扩展类加载器；应用类加载器):
##3.双亲加载模式：判断类是否已经被加载，如果已经被加载，直接返回可用的类，否则就会尝试加载，在尝试加载时，会先请求双亲处理，如果双亲请求失败，则会自己加载
##4.判断类是否加载时，应用类加载器会顺着双亲路径往上判断，直到启动类加载器。并且委托路线是单向的
##5.双亲加载模式的意义（1.防止内存中出现多份相同的字节码；2.保证Java程序的安全稳定运行）

#十三.full gc的时间节点
###13.1.System.gc()方法调用
###13.2.老年代空间不足
###13.3.方法区空间不足（方法区存放一些class的信息、常量、静态变量等数据）
###13.4.GC是出现promotion failed和concurrent mode failure
###13.5.统计得到的Minor GC晋升到旧生代平均大小大于老年代剩余空间
###13.6.堆中分配很大的对象

#十四.新生代转移到老年代的触发条件
###14.1.长期存活的对象
###14.2.大对象直接进入老年代
###14.3.minor gc后，survivor仍然放不下
###14.4.动态年龄判断 ，大于等于某个年龄的对象超过了survivor空间一半 ，大于等于某个年龄的对象直接进入老年代

#十五.Java内存模型（缓存一致性问题以及指令重排序问题）
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/JMM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png)

#十六.ClassLoader（委托、可见性、单一性）
##16.1.加载阶段
###16.1.1.通过类的全限名获取此类的二进制字节流。
###16.1.2.将这个字节流所代表的静态存储结构转换为方法区的运行时数据区
###16.1.3.在内存中生成一个代表这个类的Class对象，作为方法区的这个类的各种数据访问入口。
##.16.2.自定义类加载器
###16.2.1.可以用来加密Class文件，然后解密Class文件进行再加载，提高系统安全性
###16.2.2.从网络中加载Class文件

#十七.JVM性能调优
##17.1.JVM将内存划分为：New(年轻代)；Tenured(年老代)；Perm(永久代)
###17.1.1.年轻代：年轻代用于存放JVM刚分配的Java对象
####17.1.1.1.Eden：用来存放JVM刚分配的对象
####17.1.1.2.Survivor1,Survivor2:两个空间一样大，当Eden中的对象经过垃圾回收没有被回收掉时，会在两个Survivor之间来回copy，当满足某个条件，比如copy的次数，就会被copy到年老代，增加了对象在年轻代中的逗留时间，增加被垃圾回收的可能性
###17.1.2.年老代：年轻代中经过垃圾回收没有回收掉的对象将被copy到年老代
###17.1.3.永久代：永久代存放Class、Method元信息，大小与项目规模、类、方法的量有关，一般设置为128M就够，设置原则是预留30%的空间
##17.2.垃圾回收动作的时间
###17.2.1.当年轻代内存满时，会引发一次普通GC，该GC仅回收年轻代。需要强调的时，年轻代满是指Eden代满，Survivor满不会引发GC
###17.2.2.当年老代满时会引发Full GC，Full GC将会同时回收年轻代、年老代
###17.2.3.当永久代满时也会引发Full GC，会导致Class、Method元信息的卸载
##17.3.性能调优
###17.3.1.Java线程池：
###17.3.2.连接池：
###17.3.3.JVM参数：如果应用存在大量的临时对象，应该选择更大的年轻代；如果存在相对较多的持久对象，年老代应该适当增大。但很多应用都没有这样明显的特性，在抉择时应该根据以下两点：（A）本着Full GC尽量少的原则，让年老代尽量缓存常用对象，JVM的默认比例1：2也是这个道理 （B）通过观察应用一段时间，看其他在峰值时年老代会占多少内存，在不影响Full GC的前提下，根据实际情况加大年轻代，比如可以把比例控制在1：1。但应该给年老代至少预留1/3的增长空间；线程堆栈的设置：每个线程默认会开启1M的堆栈，用于存放栈帧、调用参数、局部变量等，对大多数应用而言这个默认值太了，一般256K就足用。理论上，在内存不变的情况下，减少每个线程的堆栈，可以产生更多的线程，但这实际上还受限于操作系统

#十八.注意
##18.1.JVM内存越大越好吗？
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B.png)

