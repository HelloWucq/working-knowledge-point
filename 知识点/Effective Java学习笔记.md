###静态工厂模式有事是个较好的选择



###如果类的构造器或者静态工厂中具有多个参数，设计这种类时，Builder模式就是一种不错的选择。


###单例模式



###避免创建不必要的对象，通过静态方法，或者静态代码块等方式，实例化出不可变对象或者不经常修改的对象，防止反复创建对象带来的开销。同时可以考虑适配器方式

###消除过期的对象引用。内存泄漏（对象引用被无意识的保留起来；只要类是自己管理内存的，一旦元素被释放掉，则该元素中包含的任何对象引用都应该被清空；注意缓存；注意监听器和其他的回调，可以通过弱引用来解决）

###始终要覆盖toString方法（返回对象中包含的所有值得关注的信息）

###除了公用静态final域的特殊情形之外，公有类不应该包含公有域，并且确保公有静态final与引用的对象都是不可变的。



###使类成为不可变（1:不要提供任何会修改对象状态的方法；2：保证类不会被扩展；3：使所有的域都是final；4：使所有的域成为私有的；5：确保对于任何可变组件的互斥访问）


###包装类不适合在回调框架中。在回调框架中，对象把自身的引用传递给其他的对象，用于后续的调用，而被包装起来的对象并不知道他外面的包装对象，所以传递一个指向自身的引用，回调时避开了外面的包装对象


###接口只用于定义类型，当类实现接口时，接口就充当可以引用这个类的实例的类型。类实现了接口，就表明客户端可以对这个类的实例实施某些动作。接口应该只被用来定义类型，而不应该被用来导出常量。

###类层次优于标签类

###函数指针的主要用途是实现策略模式。为了在Java中实现这种模式，声明一个接口来表示该策略，并为每个具体策略声明一个实现了该接口的类。当一个具体策略只被使用一次时，通常使用匿名类来声明和实例化这个具体策略类。

###嵌套类（静态成员类；内部类（非静态成员类；匿名类；局部类))非静态成员类的每个实例都隐含着与外围类的一个外围实例相关联。在非静态成员类的实例方法内部，可以调用外围实例上的方法，或者利用修饰过的this构造获得外围实例的引用。非静态成员类常见用法是定义一个Adapter;匿名类的常见用法是动态创建函数对象，创建过程对象，静态工厂方法的内部


###对于构造器的每个可变参数进行保护性拷贝是必要的


###只要能够不创建对象，就不要创建多余的对象。只要需要创建对象，就不要吝啬地创建它。

###尽可能的使用for-each循环

###优先使用接口而不是类来引用对象。如果有合适的接口类型存在，那么对于参数，返回值，变量和域来说，就都应该使用接口类型进行声明。只有当利用构造器创建某个对象时，才真正需要引进这个对象的类。


###反射功能只是在设计时使用，通常普通应用程序在运行时不应该以反射方式访问对象。


