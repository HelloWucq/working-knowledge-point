#一.Java中socket基本编程过程
##1.1.Socket通信的步骤
###1.1.1.创建ServerSocket和Socket
###1.1.2.打开连接到Socket的输入/输出流
###1.1.3.按照协议对Socket进行读/写操作
###1.1.4.关闭输入输出流、关闭Socket


#TCP编程过程
##1.2.服务器端
###1.2.1.创建ServerSocket对象，绑定监听端口
###1.2.2.通过accept()方法监听客户端请求
###1.2.3.连接建立后,通过输入流读取客户端发送的请求信息
###1.2.4.通过输出流向客户端发送相应信息
###1.2.5.关闭相关资源
##1.3.客户端
###1.3.1.创建Socket对象，指明需要连接的服务器的地址和端口号
###1.3.2.建立连接后，通过输出流向服务器端发送请求信息
###1.3.3.通过输入流获取服务器相应的信息
###1.3.4.关闭相应资源

#UDP编程过程
##1.1.服务器端
###1.1.1.创建DatagramSocket，指定端口号
###1.1.2.创建DatagramPacket
###1.1.3.接收客户端发送的数据信息
###1.1.4.读取数据
##1.2.客户端
###1.2.1.定义发送信息
###1.2.2.创建DatagramPacket，包含将要发送的信息
###1.2.3.创建DatagramSocket
###1.2.4.发送数据

#二.Java RMI技术
##2.1.RMI能让一个Java程序调用网络中另外一台计算机的Java对象的方法，效果就像这个远程计算机上的对象方法在本机上一样
##2.2.主要工作工程
###2.2.1.调用者同通常方式调用对应Java的一个远程对象方法
###2.2.2.顾客Stub的功能把相关的参数组装成一个消息包或一组消息包。运行此方法的那个站点的“地址”和对象方法的“标识符”、调用方法的参数都应包含在这个消息中
###2.2.3.将这条消息发送给对应的RMI runtime系统，该子程序转至指定的站点
###2.2.4.在接收此消息时，远程RMI runtime系统引用与被调用者对应的服务者Stub,并让他处理这条消息
###2.2.5.服务器Stub反序列化相关的参数，并用本地方法调用方式调用所需的方法。然后把调用结果序列化，向调用者返回调用结果
###2.2.6.调用者方RMI runtime系统接收返回的调用结果，。调用者Stub反序列化参数，然后返回调用结果到调用方法。
##2.3.公共对象请求代理结构


#三.JavaBean技术
##3.1.结构：特征，方法，事件
###3.1.1.特征：成员变量，描述JavaBean对象状态
###3.1.2.方法:通过规范的方法读写JavaBean成员变量
###3.1.3.事件：JavaBean特征改变引起JavaBean事件，事件激发相关对象作出反应，通过JavaBean注册对象事件监听者机制来接收、处理事件，是JavaBean通信机制
##3.2.特征分类
###3.2.1.读写方式不同：单值特征、索引特征（类似数组类型的成员变量）
###3.2.2.JavaBean特征改变激发外部类对象作出不同反应：关联特征（改变时激发相关的外部类对象）、限制特征（不仅改变时激发相关的外部类对象，而且相关的外部类对象要检查限制类特征改变的合理性）
##3.3.JavaBean事件


#四.Servlet(见Web基础学习笔记)


#五.Jsp(见Web基础学习笔记)

#六.XML技术（见Web基础学习笔记）
##6.1.DTD（文档类型定义）

#七.Java消息
##7.1.Java消息服务（JMS）
##7.2.特点：
###7.2.1异步：提供一个消息的地址即可
###7.2.2.客户与服务对象的生命周期松散耦合
###7.2.3.可靠:保证得到消息的一次性成功发送
##7.3.分类：点对点（PTP）;发布订阅
###7.3.1.点对点：以消息队列为基础（消息制造者，消息队列，消息消费者）
###7.3.2.发布订阅模型

#八.Tomcat优化
##8.1.基本思路
###8.1.1.尽量缩短单个请求的处理时间
###8.1.2.尽量可能多的并发处理请求
###8.1.3.一定要做到能横向扩展
##8.2.基本优化：合理分配Tomcat需要的内存，设置catalina.sh中的JAVA_OPTS
###8.2.1.-server：启用JDK的Server版
###8.2.2.-Xms:虚拟机初始化时的最小内存
###8.2.3.-Xmx:虚拟机可使用的最大内存（建议到物理内存的80%）
###8.2.4.-XX:MaxPermSize：持久代最大内存(默认是32M)
###8.2.5.-XX:MaxNewSize：新生代内存的最大内存(默认是16M)
##8.3.Tomcat本身的配置优化：在server.xml中<Connector>中配置（如果要加大并发连接数，应同时加大maxThreads和acceptCount，可以两个设置一样；WebServer允许的最大连接数还受制于操作系统的内核参数设置，可通过ulimit -a查看；如果配置了<Executor>，在<Connector>中通过executor属性指定参照<Executor>，那么<Connector>中关于线程的配置失效，以<Executor>中配置为准）
###8.3.1.maxConnections:最大连接数，对BIO模式，默认等于maxThreads；对NIO默认10000，对APR/native默认8192
###8.3.2.maxThreads:最大线程数，即同时处理的任务个数，默认值是200
###8.3.3.acceptCount：当处理任务的线程数达到最大时，接受排队的请求个数，默认是100
###8.3.4.minSpareThreads:最小空闲线程数，默认10
###8.3.5.compression：设置是否开启GZip压缩
###8.3.6.compressableMimeType:那些类型需要压缩，默认是text/html,text/xml,text/plain
###8.3.7.compressionMinSize:启用压缩的输出内容大小，默认是2048
###8.3.8.enableLookups:是否反差域名，为了提高处理能力，应设置false
###8.3.9.connectionTimeout:网络连接超时，单位毫秒，设置为-1表示永久不超时，通常可设置为2000毫秒


#九.Java Web高并发性能优化


#十.Tomcat请求流程
![](https://i.imgur.com/i84OK28.png)
##10.1.Acceptor 线程组。用于接受新连接，并将新连接封装一下，选择一个 Poller 将新连接添加到 Poller 的事件队列中。
##10.2.Poller 线程组。用于监听 Socket 事件，当 Socket 可读或可写等等时，将 Socket 封装一下添加到 worker 线程池的任务队列中.
##10.3.worker 线程组。用于对请求进行处理，包括分析请求报文并创建 Request 对象，调用容器的 pipeline 进行处理。

#十一.缓存
##11.1.客户端缓存
###11.1.1页面缓存
###11.1.2.浏览器缓存
###11.1.3.APP上缓存
##11.2.网络中的缓存
###11.2.1.Web代理缓存
###11.2.2.边缘缓存（CDN）
##11.3.服务器缓存
###11.3.1.数据库缓存
###11.3.2.平台级缓存
###11.3.3.应用级缓存

##11.4.术语
###11.4.1.缓存命中
###11.4.2.存储成本
###11.4.3.缓存失效
###11.4.4.替代策略
###11.4.5.动态扩容；数据多备；自动容灾

#十二.从输入url到页面加载完成发生了什么
![](https://i.imgur.com/lQUwSyA.png)



#补充知识点
##1.CGI(common gateway interface):通用网关接口：一种协议，web server可以通过将动态请求以及相关参数发送给专门处理动态内容的应用程序
##2.拆包问题：当一次发送的数据量过大，而底层不支持发送这么大的数据量，则会发生拆包现象
##3.粘包问题：当在短时间内发送很多数据量小的包时，底层会根据一定的算法（Nagle）把一些包合作一个包发送

##4.HTML5离线缓存工作流程
![](https://i.imgur.com/IKpaPIw.png)