#零.分布式经典算法
##0.1.Gossip

#一.概念
##1.1.集群
###1.1.1.节点：系统中按照协议完成计算工作的一个逻辑实体，可能是执行某些工作的进程或机器
###1.1.2.网络：系统的数据传输通道，用来彼此通信
###1.1.3.存储：系统中持久化数据的数据库或文件存储
##1.2.集群关键技术
###1.2.1.网络层：网络互联结构、通信协议、信号技术等
###1.2.2.节点机及操作系统层高性能客户机、分层或基于微内核的操作系统
###1.2.3.集群系统管理层：资源管理、资源调度、负载均衡、并行IPO、安全
###1.2.4.应用层：并行程序开发环境、串行应用、并行应用等
##1.3.幂等性
##1.4.脑裂问题


#一.分布式系统的显著特征
##1.1.并发
##1.2.缺乏全局时钟
##1.3.故障独立性
#二.Web服务器
##2.1.超文本标记语言（HTML）
##2.2.统一资源定位器（URL）
##2.3.标准交互规则（HTTP）
#三.挑战
##3.1.异构性（中间件：屏蔽底层网络，硬件，操作系统和编程语言的异构性）
##3.2.开放性
##3.3.安全性（机密性，完整性，可用性）
##3.4.可伸缩性
##3.5.故障处理
##3.6.并发性
##3.7.透明性
#四.系统模型
##4.1.体系结构模型
###4.1.1软件层（平台，中间件）
###4.1.2.系统体系结构（客户-服务器模型；对等体系结构）
###4.1.3.变体：（多个服务器提供服务；代理服务器和缓存；移动代码；移动代理，网络计算机，瘦客户，移动设备和自发互操作）
###4.1.4.接口与对象
###4.1.5.设计需求（性能问题（吞吐量；平衡计算负载，响应能力）；服务质量（可靠性，安全性和性能）；缓存和复制的使用；可依赖问题（容错与安全性））
##4.2.基础模型
###4.2.1.交互模型（1）通信通道的性能；2)计算机时钟和时序事件）
###4.2.2.故障模型（遗漏故障；随机故障；时序故障）
###4.2.3.安全模型


#五.网络原理
##5.1.数据包的传输（任意长度的数据串）
##5.2.数据流
##5.3.交互模式
###5.3.1.广播
###5.3.2.电路交换
###5.3.3.包交换
###5.3.4.帧中继
##5.4.协议
###5.4.1.必须交换的消息的顺序规约；数据格式的规约
##5.5.路由
##5.6.拥塞控制：请求减少传输率的特殊消息（阻塞数据包）
##5.7.因特网协议
###5.7.1.IP寻址（IPV6;修改IP分配方案；网络地址翻译（NAT））


#六.进程间通信

#七.分布式对象和远程调用
##7.1.分布式对象间的通信
###7.1.1.对象模型（对象引用；接口；动作；异常；无用单元收集）
##7.2.RMI（远程方法调用）
###7.2.1.通信模块：两个相互协作的通信模块执行请求-应答协议
###7.2.2.远程引用模块：在本地对象引用和远程对象引用之间进行翻译，并且负责创建远程对象的引用。
###7.2.3.伺服器：提供了远程对象主体的类的实例
###7.2.4.RMI软件（1.代理：通过对调用者表现的像本地对象一样，使远程方法调用对客户透明，将调用放在消息里传递给远程对象；2.分发器：接收来自通信模块的请求消息，并传递消息，并使用methodId选择骨架中恰当的方法；3.骨架：用于实现远程接口中的方法）
###7.2.5.服务器与客户端
###7.2.6.绑定程序
###7.2.7.服务器线程
###7.2.8.远程对象的激活
###7.2.9.持久对象存储
###7.2.10.对象定位
##7.3.RPC：过程调用不关心对象和对象的引用，不需要远程引用模块。包括一个存根过程
##7.4.事件
###7.4.1.特性：异构性；异步性
###7.4.2.参与者（兴趣对象；事件；通知；订阅者；观察者对象；发布者）


#八.操作系统层面
##8.1.基本特点：封装（提供有用的能够访问资源的服务接口）；保护（防止非法访问）；并发处理；通信；调度
##8.2.核心组件：进程管理器；线程管理器；通信管理器；内存管理器；管理器
##8.3.进程与线程
###8.3.1.地址空间：一个进程的虚拟内存管理单元
###8.3.2.新进程的生成：选择目标主机；创建执行环境
##8.4.通信与调用
###8.4.1.RPC步骤：1）一个客户存根程序将调用参数编码为消息，并将请求消息发送出去，然后接受应答消息并将其解码；2）服务器端，一个工作线程接受到达的请求，或者一个I/O线程负责接受请求，并将其传递给工作线程；3）服务器存根程序将请求消息解码，调用指定的过程并将返回值编码并发送出去。
###8.4.2.调用延迟：1）网络传输时间；2）编解码；3）数据拷贝（1.用户-内核；2.不同协议层；3.网络接口和内核缓冲区）；4）包初始化；5）线程调度和上下文切换；6）等待确认
##8.5.整体内核与微内核

#九.安全性

#十.分布式文件系统
##10.1.文件系统：负责文件的组织、存储、检索、命名、共享和保护，提供描述文件抽象的程序接口
##10.2.文件：数据+属性
##10.3.需求：1）透明性；2）并发文件更新；3）文件复制；4）硬件和操作系统异构性；5）容错；6）一致性；7）安全性；8）效率
##10.4.文件服务体系结构
###10.4.1.平面文件服务
###10.4.2.目录服务
###10.4.3.客户模块
###10.4.4.平面文件服务接口
###10.4.5.访问控制
###10.4.6.目录服务接口
###10.4.7.层次文件系统
###10.4.8.文件组
##10.5.缓存
##10.6.主要问题
###10.6.1.有效的使用客户缓存以便获得和本地文件系统相同甚至更好的性能
###10.6.2.当文件更新是，维护文件的多个客户拷贝一致性
###10.6.3.在客户与服务器发生故障后进行恢复
###10.6.4.提高读写不同大小文件的吞吐量
###10.6.5.可伸缩性


#十一.名字服务
##11.1.存储了一个或多个命名上下文
##11.2.名字空间
##11.3.名字解析

#十二.对等系统
##12.1.关键问题：数据对象在多主机环境中的放置问题，以及考虑系统在负载平衡的前提下访问数据的方式，并且在不增加不必要开销的情况下保证系统的可用性


#十三.时间和全局状态
##13.1.时钟、事件和进程状态

#十四.协调和协定
##14.1.互斥算法
###14.1.1.集中式算法
###14.1.2.分布式算法
###14.1.3.令牌环算法
##14.2.选举算法
###14.2.1.环算法
###14.2.2.Paxos算法
###14.2.3.Google Chubby
###14.2.4.Zab算法
###14.2.5.Bully Algorithm 霸道算法
###14.2.6.raft算法
##14.3.组播通信
##14.4.共识：拜占庭将军问题；交互一致性；共识问题与其他问题的关联


#十五.事务与并发控制
##15.1.ACID
##15.2.CAP（一致性；可用性；分区容错性）
##15.3.BASE(基本可用；软状态；最终一致性)
##15.4解决方案
###15.4.1.两阶段提交（1.务协调器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交；2.事务协调器要求每个数据库提交数据）:单点问题；同步阻塞；数据不一致
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/2PC%E6%8F%90%E4%BA%A4%E7%A4%BA%E6%84%8F%E5%9B%BE.png)
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4.png)
###15.4.2.三阶段提交（1.Try 阶段主要是对业务系统做检测及资源预留；2.Confirm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默认 Confirm阶段是不会出错的；3.Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放）：
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/%E4%B8%89%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4.png)
###15.4.3.本地消息表（此方案的核心是将需要分布式处理的任务通过消息日志的方式来异步执行）
###15.4.4.MQ事务
###15.4.5.Saga事务


#十六.分布式锁
#十七.复制
#十八.Web服务

#十九.分布式中间件
##19.1.分布式系统的定义：一是组件分布在网络计算机上；二是组件之间仅仅通过消息传递来通信并协调行动

##19.2.分布式系统的基础知识
###19.2.1.多进程相对多线程会涉及序列化与反序列化的开销

##19.3.分布式系统的难点
###19.3.1.缺乏全局时钟
###19.3.2.面对故障独立性
###19.3.3.处理单点故障
###19.3.4.事务的挑战

##19.4.大型网站的架构演进
###19.4.1.Session问题：会话数据需要保存在单机上
###19.4.2.Session问题的常见解决方法：
####19.4.2.1.Session Sticky(1.若一台Web服务器宕机或重启，会话数据就会丢失；2.会话标识是应用层的信息，负载均衡要将同一个会话请求保存到同一个Web服务器，就需要进行应用层解析，这个开销比第四层的交换大；3.负载均衡器变成一个有状态节点，要将会话保存到具体Web服务器，内存消耗更大，容灾方面会更麻烦)
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/Session%20Sticky.png)
####19.4.2.2.Session Replication(同步Session数据造成网络带宽的开销；每台Web服务器都要保存所有的Session数据，每台机器用于保存Session数据的内容占用会很严重)
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/Session%20Replication.png)
####19.4.2.3.Session数据集中存储(读写Session数据引入了网络操作，存在时延性和不稳定性;集中存储的Session机器或集群出现问题影响应用)
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/Session%E9%9B%86%E4%B8%AD%E5%AD%98%E5%82%A8.png)
####19.4.2.4.Cookie Based(Cookie长度的限制；安全性；带宽消耗；性能影响)
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/Cookie%20Based.png)

###19.4.3.数据库问题
###19.4.3.1.数据库压力大，读写分离：采用数据库作为读库（数据复制问题；应用对于数据源的选择问题）
####19.4.3.2.加速数据读取-----缓存
- 数据缓存
- 页面缓存
####19.4.3.3.分布式数据库
####19.4.3.4.专库专用，数据垂直拆分
####19.4.3.5.数据水平拆分


##19.5.服务化（使得原来的一些本地调用变成远程调用，问题的关键提高易用性以及降低性能损失）
###19.5.1.应用从集中式走向分布式的问题


##二十.Zookeeper
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/Zookeeper%E6%8F%90%E4%BA%A4%E7%A4%BA%E6%84%8F%E5%9B%BE.png)
##20.1.leader的角色（Zookeeper集群的核心）
###20.1.1.事务请求的唯一调度和处理者，保证集群事务处理的顺序性
###20.1.2.集群内部各服务器的调度者

##20.2.follower的角色
###20.2.1.处理客户端非事务请求，转发事务请求给leader服务器
###20.2.2.参与事务请求proposal的投票（需要半数书以上服务器通过才能通知leader commit数据，leader发起的提案要follower投票）
###20.2.3.参与leader选举的投票

##20.3.observer角色：observer服务器只提供非事务请求服务，通常在于不影响集群事务处理能力的前提下提升集群非事务处理的能力


##20.4.基本数据模型：类似Linux文件系统的节点模型
###20.4.1.同一时刻多台机器创建同一个节点，只有一个会争抢成功。利用这个特性可以做分布式锁。
###20.4.2.临时节点的生命周期与会话一致，会话关闭则临时节点删除。这个特性经常用来做心跳，动态监控，负载等动作。
###20.4.3.顺序节点保证节点名全局唯一。这个特性可以用来生成分布式环境下的全局自增长id。

##20.5.ZAB协议：消息广播可以说是一个简化版本的 2PC，通过崩溃恢复解决了 2PC 的单点问题，通过队列解决了 2PC 的同步阻塞问题。
###20.5.1.消息广播
[https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/ZAB%E7%9A%84%E6%B6%88%E6%81%AF%E5%B9%BF%E6%92%AD.png](https://github.com/HelloWucq/working-knowledge-point/blob/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/ZAB%E7%9A%84%E6%B6%88%E6%81%AF%E5%B9%BF%E6%92%AD.png)
- Leader 在收到客户端请求之后，会将这个请求封装成一个事务，并给这个事务分配一个全局递增的唯一 ID，称为事务ID（ZXID），ZAB 兮协议需要保证事务的顺序，因此必须将每一个事务按照 ZXID 进行先后排序然后处理。
- 在 Leader 和 Follwer 之间还有一个消息队列，用来解耦他们之间的耦合，解除同步阻塞。
- zookeeper集群中为保证任何所有进程能够有序的顺序执行，只能是 Leader 服务器接受写请求，即使是 Follower 服务器接受到客户端的请求，也会转发到 Leader 服务器进行处理。
- 实际上，这是一种简化版本的 2PC，不能解决单点问题。等会我们会讲述 ZAB 如何解决单点问题（即 Leader 崩溃问题）
###20.5.2.崩溃恢复：如果让 Leader 选举算法能够保证新选举出来的 Leader 服务器拥有集群总所有机器编号（即 ZXID 最大）的事务
- ZAB 协议确保那些已经在 Leader 提交的事务最终会被所有服务器提交。
- ZAB 协议确保丢弃那些只在 Leader 提出/复制，但没有提交的事务。



#二十一.大型分布式网站术语分析
##21.1.I/O优化
###21.1.1.增加缓存，减少磁盘的访问次数。
###21.1.2.优化磁盘的管理系统，设计最优的磁盘方式策略，以及磁盘的寻址策略，这是在底层操作系统层面考虑的。
###21.1.3.设计合理的磁盘存储数据块，以及访问这些数据库的策略，这是在应用层面考虑的。例如，我们可以给存放的数据设计索引，通过寻址索引来加快和减少磁盘的访问量，还可以采用异步和非阻塞的方式加快磁盘的访问速度。
###21.1.4.应用合理的RAID策略提升磁盘I/O。

##21.2.Web前端调优
###21.2.1.减少网络交互的次数（多次请求合并）
###21.2.2.减少网络传输数据量的大小(压缩)
###21.2.3.尽量减少编码（尽量提前将字符转化为字节，或者减少从字符到字节的转化过程。）
###21.2.4.使用浏览器缓存
###21.2.5.减少Cookie传输
###21.2.6.合理布局页面
###21.2.7.使用页面压缩
###21.2.8.延迟加载页面
###21.2.9.CSS在最上面，JS在最下面
###21.2.10.CDN
###21.2.11.反向代理
###21.2.12.页面静态化
###21.2.13.异地部署

##21.3.服务降级：拒绝服务和关闭服务
##21.4.幂等性设计
##21.5.失效转移：失效确认（心跳检测和应用程序访问失败报告）、访问转移、数据恢复。

##21.6.应用服务器性能优化
###21.6.1.分布式缓存（Redis等）
###21.6.2.异步操作（消息队列）
###21.6.3.使用集群（负载均衡）
###21.6.4.代码优化



#二十二.分布式系统设计策略
##22.1.设计策略
###22.1.1.心跳检测（周期检测心跳策略；累计失效检测策略）
###22.1.2.高可用设计（主备模式；互备模式；集群）
###22.1.3.容错性
###22.1.4.负载均衡
####22.1.4.1.F5
####22.1.4.2.Nginx（轮询；最少连接；IP地址哈希；基于权重的负载均衡）

#二十三.设计实践
##23.1.全局ID生成（UUID;ID生成表模式；Snowflake；结合缓存方案）
##23.2.哈希取模
##23.3.一致性哈希
##23.4.路由表
##23.5.数据拆分


#二十四.熔断和限流[https://www.jianshu.com/p/52dc87011109](https://www.jianshu.com/p/52dc87011109)



#注意
###1.[https://www.jianshu.com/p/2d91a84b7cf5](https://www.jianshu.com/p/2d91a84b7cf5 "分布式处理方案")
##2.分布式Session
###2.1.解决方案：1）使用cookie来完成（很明显这种不安全的操作并不可靠）；2）使用Nginx中的ip绑定策略，同一个ip只能在指定的同一个机器访问（不支持负载均衡）；3）利用数据库同步session（效率不高）；4）使用tomcat内置的session同步（同步可能会产生延迟）；5）使用token代替session
##3.常见解决一致性问题的方式
###3.1.查询重试补偿。对于分布式应用中不确定的情况，先使用查询接口查询到当前状态，如果当前状态不一致则采用补偿接口对状态进行重试推进，或者回滚接口对业务做回滚。典型的场景如银行跟支付宝之间的交互。支付宝发送一个转账请求到银行，如一直未收到响应，则可以通过银行的查询接口查询该笔交易的状态，如该笔交易对方未收到，则采取补偿的模式进行推送。
###3.2.定时任务推送。对于上面的情况，有可能一次推送搞不定，于是需要2次，3次推送。不要怀疑，支付宝内最初掉单率很高，全靠后续不断的定时任务推送增加成功率。
###3.3.TCC。try-confirm-cancel。实际上是两阶段协议，第二阶段的可以实现提交操作或是逆操作。




----------

----------
#1.基本知识
##1.1.分布式系统的难点
- 缺乏全局时钟
- 面对故障独立性
- 处理单点故障
	- 给单点做好备份，能够在出现问题是进行自动恢复
	- 降低单点故障的影响范围
- 事务的挑战

#2.中间件
- 远程过程调用和对象访问中间件：主要解决分布式环境下应用的互相访问问题
- 消息中间件：解决应用之间的消息传递、解耦、异步的问题
- 数据访问中间件：解决应用访问数据库的共性问题的组件

##2.1.服务框架
###2.1.1.服务调用端的设计
- 远程通信遇到的问题
	- 通过中间代理，透明代理模式
	- 服务注册查找中心，从而来寻址和路由（负载均衡）
- 服务调用端的流控处理
	- 一种是0-1开关，也就是完全打开不进行流控
	- 设定一个固定的值，表示每秒可以进行的请求次数，超过这个请求数的话就拒绝对远程的请求，那些被流量控制拒绝的请求，可以直接返回给调用者，也可以进行排队
		- 根据服务端自身的接口、方法做控制，也就是针对不同的接口、方法设置不同的阈值，为了使服务端的不同接口、方法之间的负载不互相影响
		- 根据来源控制，对于同样的接口、方法，根据不同来源设置不同的限制，这一般用在比较基础的服务上，也就是在多个集群使用同样的服务时，根据请求来源的不同级别等进行不同的流控处理  
- 序列化与反序列化
- 网络通信实现选择
- 异步服务调用方式
	- oneway：只管发送请求而不关心结果的方式 
	- callback:请求方发送请求后会继续执行自己的操作，等对方有响应式进行回调
	- future
	- 可靠异步

###2.1.2.服务提供端
- 本地服务的注册管理
- 根据进来的请求定位服务并执行

###2.1.3.服务升级
- 接口不变，只是代码本身进行完善，采用灰度发布的方式就行
- 需要修改原有的接口
	- 接口中增加方法
	- 对接口的某些方法修改调用的参数列表 
		- 对使用原来的代码进行修改，然后和服务端一起发布（不科学）
		- 通过版本号解决
		- 在设计方法上考虑参数的扩展性（不太好）
##2.2.服务治理
-  服务信息
	- 服务编码，即数字化的服务编码
	- 支持编码的注册
	- 根据编码定位服务信息
- 服务质量：根据被调用服务的出错率，响应时间等数据对服务质量进行评估
	- 最好、最差的服务排行
	- 各个服务的质量趋势
	- 各种查询条件的支持
- 服务容量
	- 服务容量与当前水位的展示
	- 历史趋势图
	- 根据水位的高地排序    
	- 各种查询条件的支持
- 服务依赖
	- 依赖服务展示
	- 被依赖展示
	- 依赖变化
- 服务分布
	- 服务在不同机房分布
	- 服务在不同机柜分布
	- 分布不均衡服务列表
- 服务统计
	- 调用次数统计和排名
	-  出错次数统计和排名
	-  出错统计和排名
	-  响应时间统计和排名
	-  响应时间趋势
	-  出错率趋势
- 服务元数据
	- 服务的方法和参数
- 服务查询
	- 服务的应用负责人、测试负责人
	- 服务所属的应用名称
	- 服务发布时间
	- 服务提供者的地址列表
	- 服务容量
	- 服务质量
	- 服务调用次数
	- 服务依赖
	- 服务版本号及归组信息等
- 服务报表
- 服务监视      


----------
- 服务上下线
	- 针对一个服务所有机器的上线和下线操作
	- 针对指定机器的上线和下线操作
	- DoubleCheck控制
- 服务路由：路由策略的管理
	- 路由管理界面支持
	- 路由信息更改前后对比和验证
	- 路由配置多版本管理和回滚
	- DoubleCheck控制
- 服务限流降级
	- 根据调用来源限流
	- 根据具体服务限流
	- 针对服务开关降级
	- 流控、降级配置多版本管理和回滚
	- DoubleCheck控制
- 服务归组： 在集中的控制台调整服务的分组信息
	- 归组规则的多版本管理和回滚
	- 归组规则预览
	- 归组规则的影响范围和评估
	- DoubleCheck控制   
- 服务线程池管理
	- 调用方的线程管理，最大并发的管理
	- 服务端线程工作状况查询
	- 服务端针对不同服务的多个业务线程池的管理
	- DoubleCheck控制
- 机房规则
	- 规则查询和发布校验
	- 规则多版本管理和回滚
	- DoubleCheck控制
- 服务授权
	- 授权信息查询
	- 授权规则多版本支持和回滚
	- DoubleCheck控制        
 
##3.数据访问层
###3.1.垂直拆分
- 单机的ACID保证被打破了
- 一些join操作变得比较复杂
- 靠外键进行约束的场景会受影响

###3.2.水平拆分
- ACID可能被打破
- Join操作可能被影响
- 靠外键进行约束的场景会有影响
- 依赖单库的自增序列生成唯一ID会受影响
- 针对单个逻辑意义上的表查询要跨库了

##3.3.分布式事务
- 应用程序：定义了事务边界，并定义了构成该事务的应用程序的特定操作
- 资源管理器：通过资源管理器对资源进行控制
- 事务管理器：负责协调和管理事务，控制着全局事务，管理事务的生命周期，并协调资源

###3.3.1.CAP/BASE
###3.3.2.Paxos协议

###3.3.3.多机Sequence问题和处理
- 唯一性：UUID
- 连续性

###3.3.4.应对多机的数据查询
- 跨库Join
	- 在应用层把原来数据库的Join操作分成多次的数据库操作
	- 数据冗余
	- 借助外部系统
- 外键约束  

##3.4.数据访问层

##3.5.读写分离的挑战
- 主库从库非对称的场景
- 平滑迁移

#4.消息中间件
##4.1.消息发送一致性问题
##4.2.消息模型



----------
#分布式存储
##1.基本概念
- 特性
	- 扩展性
	- 低成本
	- 高性能
	- 易用 
- 挑战
	- 数据分布
	- 一致性
	- 容错
	- 负载均衡
	- 事务与并发控制
	- 易用性
	- 压缩/解压缩 

##2.单机存储系统
###2.1.宕机存储引擎
- 哈希存储引擎
- B树存储引擎
- LSM树存储引擎：将对数据的修改增量保持在内存中，达到指定的大小限制后将这些修改操作批量写入磁盘，读取时需要合并磁盘中的历史数据和内存中最近的修改操作

###2.2.数据模型
- 文件模型
- 关系模型
- 键值模型

###2.3.事务与控制并发
- 事务
	- 基本属性（ACID）
	- SQL隔离级别
- 并发控制
	- 数据库锁
	- 写时复制
	- 多版本并发控制

###2.4.故障恢复
- 操作日志
- 重做日志
	- 将REDO日志一追加写的方式写入磁盘的日志文件
	- 将REDO日志的修改操作应用到内存中
	- 放回操作成功或失败 
- 回滚日志 
> 优化手段

	- 成组提交
	- 检查点 
###2.5.数据压缩

##3.分布式系统
###3.1.基本概念
- 异常
- 超时
- 一致性
	- 强一致性
	- 最终一致性
- 衡量指标  

###3.2.数据分布
- 哈希分布（一致性哈希）
- 顺序分布

###3.3.复制
###3.4.容错
- 故障检测
	- 心跳检查 
- 故障恢复

###3.5.可扩展性
- 总控节点：用于维护数据分布信息，执行工作机管理，数据定位，故障检测和恢复，负载均衡等全局调度工作
- 数据库扩容
	- 主从复制提高系统的读取能力，通过垂直拆分和水平拆分将数据分布到多个存储节点，通过主从复制将系统扩展到多个数据中心


##4.分布式文件系统