#零.分布式经典算法
##0.1.Gossip

#一.概念
##1.1.集群
###1.1.1.节点：系统中按照协议完成计算工作的一个逻辑实体，可能是执行某些工作的进程或机器
###1.1.2.网络：系统的数据传输通道，用来彼此通信
###1.1.3.存储：系统中持久化数据的数据库或文件存储
##1.2.集群关键技术
###1.2.1.网络层：网络互联结构、通信协议、信号技术等
###1.2.2.节点机及操作系统层高性能客户机、分层或基于微内核的操作系统
###1.2.3.集群系统管理层：资源管理、资源调度、负载均衡、并行IPO、安全
###1.2.4.应用层：并行程序开发环境、串行应用、并行应用等
##1.3.幂等性
##1.4.脑裂问题


#一.分布式系统的显著特征
##1.1.并发
##1.2.缺乏全局时钟
##1.3.故障独立性
#二.Web服务器
##2.1.超文本标记语言（HTML）
##2.2.统一资源定位器（URL）
##2.3.标准交互规则（HTTP）
#三.挑战
##3.1.异构性（中间件：屏蔽底层网络，硬件，操作系统和编程语言的异构性）
##3.2.开放性
##3.3.安全性（机密性，完整性，可用性）
##3.4.可伸缩性
##3.5.故障处理
##3.6.并发性
##3.7.透明性
#四.系统模型
##4.1.体系结构模型
###4.1.1软件层（平台，中间件）
###4.1.2.系统体系结构（客户-服务器模型；对等体系结构）
###4.1.3.变体：（多个服务器提供服务；代理服务器和缓存；移动代码；移动代理，网络计算机，瘦客户，移动设备和自发互操作）
###4.1.4.接口与对象
###4.1.5.设计需求（性能问题（吞吐量；平衡计算负载，响应能力）；服务质量（可靠性，安全性和性能）；缓存和复制的使用；可依赖问题（容错与安全性））
##4.2.基础模型
###4.2.1.交互模型（1）通信通道的性能；2)计算机时钟和时序事件）
###4.2.2.故障模型（遗漏故障；随机故障；时序故障）
###4.2.3.安全模型


#五.网络原理
##5.1.数据包的传输（任意长度的数据串）
##5.2.数据流
##5.3.交互模式
###5.3.1.广播
###5.3.2.电路交换
###5.3.3.包交换
###5.3.4.帧中继
##5.4.协议
###5.4.1.必须交换的消息的顺序规约；数据格式的规约
##5.5.路由
##5.6.拥塞控制：请求减少传输率的特殊消息（阻塞数据包）
##5.7.因特网协议
###5.7.1.IP寻址（IPV6;修改IP分配方案；网络地址翻译（NAT））


#六.进程间通信

#七.分布式对象和远程调用
##7.1.分布式对象间的通信
###7.1.1.对象模型（对象引用；接口；动作；异常；无用单元收集）
##7.2.RMI（远程方法调用）
###7.2.1.通信模块：两个相互协作的通信模块执行请求-应答协议
###7.2.2.远程引用模块：在本地对象引用和远程对象引用之间进行翻译，并且负责创建远程对象的引用。
###7.2.3.伺服器：提供了远程对象主体的类的实例
###7.2.4.RMI软件（1.代理：通过对调用者表现的像本地对象一样，使远程方法调用对客户透明，将调用放在消息里传递给远程对象；2.分发器：接收来自通信模块的请求消息，并传递消息，并使用methodId选择骨架中恰当的方法；3.骨架：用于实现远程接口中的方法）
###7.2.5.服务器与客户端
###7.2.6.绑定程序
###7.2.7.服务器线程
###7.2.8.远程对象的激活
###7.2.9.持久对象存储
###7.2.10.对象定位
##7.3.RPC：过程调用不关心对象和对象的引用，不需要远程引用模块。包括一个存根过程
##7.4.事件
###7.4.1.特性：异构性；异步性
###7.4.2.参与者（兴趣对象；事件；通知；订阅者；观察者对象；发布者）


#八.操作系统层面
##8.1.基本特点：封装（提供有用的能够访问资源的服务接口）；保护（防止非法访问）；并发处理；通信；调度
##8.2.核心组件：进程管理器；线程管理器；通信管理器；内存管理器；管理器
##8.3.进程与线程
###8.3.1.地址空间：一个进程的虚拟内存管理单元
###8.3.2.新进程的生成：选择目标主机；创建执行环境
##8.4.通信与调用
###8.4.1.RPC步骤：1）一个客户存根程序将调用参数编码为消息，并将请求消息发送出去，然后接受应答消息并将其解码；2）服务器端，一个工作线程接受到达的请求，或者一个I/O线程负责接受请求，并将其传递给工作线程；3）服务器存根程序将请求消息解码，调用指定的过程并将返回值编码并发送出去。
###8.4.2.调用延迟：1）网络传输时间；2）编解码；3）数据拷贝（1.用户-内核；2.不同协议层；3.网络接口和内核缓冲区）；4）包初始化；5）线程调度和上下文切换；6）等待确认
##8.5.整体内核与微内核

#九.安全性

#十.分布式文件系统
##10.1.文件系统：负责文件的组织、存储、检索、命名、共享和保护，提供描述文件抽象的程序接口
##10.2.文件：数据+属性
##10.3.需求：1）透明性；2）并发文件更新；3）文件复制；4）硬件和操作系统异构性；5）容错；6）一致性；7）安全性；8）效率
##10.4.文件服务体系结构
###10.4.1.平面文件服务
###10.4.2.目录服务
###10.4.3.客户模块
###10.4.4.平面文件服务接口
###10.4.5.访问控制
###10.4.6.目录服务接口
###10.4.7.层次文件系统
###10.4.8.文件组
##10.5.缓存
##10.6.主要问题
###10.6.1.有效的使用客户缓存以便获得和本地文件系统相同甚至更好的性能
###10.6.2.当文件更新是，维护文件的多个客户拷贝一致性
###10.6.3.在客户与服务器发生故障后进行恢复
###10.6.4.提高读写不同大小文件的吞吐量
###10.6.5.可伸缩性


#十一.名字服务
##11.1.存储了一个或多个命名上下文
##11.2.名字空间
##11.3.名字解析

#十二.对等系统
##12.1.关键问题：数据对象在多主机环境中的放置问题，以及考虑系统在负载平衡的前提下访问数据的方式，并且在不增加不必要开销的情况下保证系统的可用性


#十三.时间和全局状态
##13.1.时钟、事件和进程状态

#十四.协调和协定
##14.1.互斥算法
###14.1.1.集中式算法
###14.1.2.分布式算法
###14.1.3.令牌环算法
##14.2.选举算法
###14.2.1.环算法
###14.2.2.Paxos算法
###14.2.3.Google Chubby
###14.2.4.Zab算法
###14.2.5.Bully Algorithm 霸道算法
###14.2.6.raft算法
##14.3.组播通信
##14.4.共识：拜占庭将军问题；交互一致性；共识问题与其他问题的关联


#十五.事务与并发控制
##15.1.ACID
##15.2.CAP（一致性；可用性；分区容错性）
##15.3.BASE(基本可用；软状态；最终一致性)
##15.4解决方案
###15.4.1.两阶段提交（1.务协调器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交；2.事务协调器要求每个数据库提交数据）:单点问题；同步阻塞；数据不一致
![](https://i.imgur.com/nabrq5U.png)
![](https://i.imgur.com/WHdO9cV.png)
###15.4.2.三阶段提交（1.Try 阶段主要是对业务系统做检测及资源预留；2.Confirm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默认 Confirm阶段是不会出错的；3.Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放）：
![](https://i.imgur.com/Lq7eemj.png)
###15.4.3.本地消息表（此方案的核心是将需要分布式处理的任务通过消息日志的方式来异步执行）
###15.4.4.MQ事务
###15.4.5.Saga事务


#十六.分布式锁
#十七.复制
#十八.Web服务

#十九.分布式中间件
##19.1.分布式系统的定义：一是组件分布在网络计算机上；二是组件之间仅仅通过消息传递来通信并协调行动

##19.2.分布式系统的基础知识
###19.2.1.多进程相对多线程会涉及序列化与反序列化的开销

##19.3.分布式系统的难点
###19.3.1.缺乏全局时钟
###19.3.2.面对故障独立性
###19.3.3.处理单点故障
###19.3.4.事务的挑战

##19.4.大型网站的架构演进
###19.4.1.Session问题：会话数据需要保存在单机上
###19.4.2.Session问题的常见解决方法：
####19.4.2.1.Session Sticky(1.若一台Web服务器宕机或重启，会话数据就会丢失；2.会话标识是应用层的信息，负载均衡要将同一个会话请求保存到同一个Web服务器，就需要进行应用层解析，这个开销比第四层的交换大；3.负载均衡器变成一个有状态节点，要将会话保存到具体Web服务器，内存消耗更大，容灾方面会更麻烦)
![](https://i.imgur.com/fPBwuSc.png)
####19.4.2.2.Session Replication(同步Session数据造成网络带宽的开销；每台Web服务器都要保存所有的Session数据，每台机器用于保存Session数据的内容占用会很严重)
![](https://i.imgur.com/MroBpsA.png)
####19.4.2.3.Session数据集中存储(读写Session数据引入了网络操作，存在时延性和不稳定性;集中存储的Session机器或集群出现问题影响应用)
![](https://i.imgur.com/Wj23r5L.png)
####19.4.2.4.Cookie Based(Cookie长度的限制；安全性；带宽消耗；性能影响)
![](https://i.imgur.com/R39qGgR.png)

###19.4.3.数据库问题
###19.4.3.1.数据库压力大，读写分离：采用数据库作为读库（数据复制问题；应用对于数据源的选择问题）
####19.4.3.2.加速数据读取-----缓存
####19.4.3.3.分布式数据库
####19.4.3.4.专库专用，数据垂直拆分
####19.4.3.5.数据水平拆分


##19.5.服务化（使得原来的一些本地调用变成远程调用，问题的关键提高易用性以及降低性能损失）
###19.5.1.应用从集中式走向分布式的问题


##二十.Zookeeper
![](https://i.imgur.com/lgmDgx3.png)
##20.1.leader的角色（Zookeeper集群的核心）
###20.1.1.事务请求的唯一调度和处理者，保证集群事务处理的顺序性
###20.1.2.集群内部各服务器的调度者

##20.2.follower的角色
###20.2.1.处理客户端非事务请求，转发事务请求给leader服务器
###20.2.2.参与事务请求proposal的投票（需要半数书以上服务器通过才能通知leader commit数据，leader发起的提案要follower投票）
###20.2.3.参与leader选举的投票

##20.3.observer角色：observer服务器只提供非事务请求服务，通常在于不影响集群事务处理能力的前提下提升集群非事务处理的能力


##20.4.基本数据模型：类似Linux文件系统的节点模型
###20.4.1.同一时刻多台机器创建同一个节点，只有一个会争抢成功。利用这个特性可以做分布式锁。
###20.4.2.临时节点的生命周期与会话一致，会话关闭则临时节点删除。这个特性经常用来做心跳，动态监控，负载等动作。
###20.4.3.顺序节点保证节点名全局唯一。这个特性可以用来生成分布式环境下的全局自增长id。


#二十一.大型分布式网站术语分析
##21.1.I/O优化
###21.1.1.增加缓存，减少磁盘的访问次数。
###21.1.2.优化磁盘的管理系统，设计最优的磁盘方式策略，以及磁盘的寻址策略，这是在底层操作系统层面考虑的。
###21.1.3.设计合理的磁盘存储数据块，以及访问这些数据库的策略，这是在应用层面考虑的。例如，我们可以给存放的数据设计索引，通过寻址索引来加快和减少磁盘的访问量，还可以采用异步和非阻塞的方式加快磁盘的访问速度。
###21.1.4.应用合理的RAID策略提升磁盘I/O。

##21.2.Web前端调优
###21.2.1.减少网络交互的次数（多次请求合并）
###21.2.2.减少网络传输数据量的大小(压缩)
###21.2.3.尽量减少编码（尽量提前将字符转化为字节，或者减少从字符到字节的转化过程。）
###21.2.4.使用浏览器缓存
###21.2.5.减少Cookie传输
###21.2.6.合理布局页面
###21.2.7.使用页面压缩
###21.2.8.延迟加载页面
###21.2.9.CSS在最上面，JS在最下面
###21.2.10.CDN
###21.2.11.反向代理
###21.2.12.页面静态化
###21.2.13.异地部署

##21.3.服务降级：拒绝服务和关闭服务
##21.4.幂等性设计
##21.5.失效转移：失效确认（心跳检测和应用程序访问失败报告）、访问转移、数据恢复。

##21.6.应用服务器性能优化
###21.6.1.分布式缓存（Redis等）
###21.6.2.异步操作（消息队列）
###21.6.3.使用集群（负载均衡）
###21.6.4.代码优化



#二十二.分布式系统设计策略
##22.1.设计策略
###22.1.1.心跳检测（周期检测心跳策略；累计失效检测策略）
###22.1.2.高可用设计（主备模式；互备模式；集群）
###22.1.3.容错性
###22.1.4.负载均衡
####22.1.4.1.F5
####22.1.4.2.Nginx（轮询；最少连接；IP地址哈希；基于权重的负载均衡）

#二十三.设计实践
##23.1.全局ID生成（UUID;ID生成表模式；Snowflake；结合缓存方案）
##23.2.哈希取模
##23.3.一致性哈希
##23.4.路由表
##23.5.数据拆分






#注意
###1.[https://www.jianshu.com/p/2d91a84b7cf5](https://www.jianshu.com/p/2d91a84b7cf5 "分布式处理方案")
##2.分布式Session
###2.1.解决方案：1）使用cookie来完成（很明显这种不安全的操作并不可靠）；2）使用Nginx中的ip绑定策略，同一个ip只能在指定的同一个机器访问（不支持负载均衡）；3）利用数据库同步session（效率不高）；4）使用tomcat内置的session同步（同步可能会产生延迟）；5）使用token代替session
##3.常见解决一致性问题的方式
###3.1.查询重试补偿。对于分布式应用中不确定的情况，先使用查询接口查询到当前状态，如果当前状态不一致则采用补偿接口对状态进行重试推进，或者回滚接口对业务做回滚。典型的场景如银行跟支付宝之间的交互。支付宝发送一个转账请求到银行，如一直未收到响应，则可以通过银行的查询接口查询该笔交易的状态，如该笔交易对方未收到，则采取补偿的模式进行推送。
###3.2.定时任务推送。对于上面的情况，有可能一次推送搞不定，于是需要2次，3次推送。不要怀疑，支付宝内最初掉单率很高，全靠后续不断的定时任务推送增加成功率。
###3.3.TCC。try-confirm-cancel。实际上是两阶段协议，第二阶段的可以实现提交操作或是逆操作。

