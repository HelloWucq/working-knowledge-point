#一.负载均衡：[https://www.jianshu.com/p/85dc5fe504e9](https://www.jianshu.com/p/85dc5fe504e9 "负载均衡")
##1.1.负载均衡策略：
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5.png)
##1.2.健康探测保持高可用：
###1.2.1.HTTP探测：使用Get/Post的方式请求服务端的某个固定的URL，判断返回的内容是否符合预期。一般使用Http状态码、response中的内容来判断。
###1.2.2.TCP探测：基于Tcp的三次握手机制来探测指定的IP + 端口
###1.2.3.UDP探测：可能有部分应用使用的UDP协议。在此协议下可以通过报文来进行探测指定的IP + 端口
##1.3.一致性哈希
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C.png)
#二.高并发的缓存问题
##2.1.缓存一致性问题：缓存的过期和更新策略
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98.png)
##2.2.缓存并发问题：锁机制
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/%E7%BC%93%E5%86%B2%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98.png)
##2.3.缓存穿透
###2.3.1.缓存空对象
###2.3.2.单独过滤处理
##2.4.缓存颠簸问题：一致性Hash算法来解决
##2.5.缓存的雪崩现象
#三.RPC消息协议
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/RPC%E6%B6%88%E6%81%AF%E5%8D%8F%E8%AE%AE.png)
#四.微服务架构：[https://www.jianshu.com/p/b75041dc6bb6](https://www.jianshu.com/p/b75041dc6bb6 "微服务")
##4.1.组件：
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6.png)
#五.加密技术
##5.1.数字摘要
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/%E6%95%B0%E5%AD%97%E6%91%98%E8%A6%81.png)
##5.2.对称加密
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86.png)
##5.3.非对称加密
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86.png)
##5.4.数字签名
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D.png)
##5.5.数字证书

#六.操作系统相关知识学习
##6.1.进程环境
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83.png)
##6.2.系统调用：man
##6.3.虚拟内存
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.png)
##6.4.内存管理：内核尽力保持最活跃的数据在主存中
###6.4.1.交换：让整个进程在主存和二级存储之间移动
###6.4.2.换页：移动称为页的小的内存单元
###6.4.3.换页是移动小页面，交换是移动整个进程
##6.5.文件系统
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.png)
##6.6.系统观测数据


#七.性能技术
##7.1.I/O:执行I/O的开销包括初始化缓冲区、系统调用、上下文切换、分配内核元数据、检查进程权限和限制、映射地址到设备、执行内核和驱动代码来执行I/O，以及在最后释放元数据和缓冲区
###7.1.1.增加I/O的尺寸是提高吞吐量的常用策略
##7.2.缓存
##7.3.缓存区（环形缓存区）
##7.4.轮询（select/poll/epoll）
##7.5.并发与并行
##7.6.非阻塞I/O（减小上下文切换）
##7.7.处理器绑定（CPU亲和性）：进程绑定；独占CPU组

#八.CPU
##8.1.基本概念
###8.1.1.时钟频率
###8.1.2.指令
###8.1.3.指令流水线
###8.1.4.指令宽度
###8.1.5.CPI(每指令周期数)；IPC(每周期指令数)
###8.1.6.用户时间/内核时间
###8.1.7.饱和度
###8.1.8.优先级反转
###8.1.9.多线程与多进程
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%A4%9A%E8%BF%9B%E7%A8%8B.png)
###8.1.10.字长
##8.2.CPU缓存(延时、相联性、缓存行、缓存一致性、MMU、互联)
##8.3.调度器
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/%E5%86%85%E6%A0%B8%E8%B0%83%E5%BA%A6%E5%99%A8.png)

#九.内存
##9.1.基本概念
###9.1.1.虚拟内存
###9.1.2.换页（文件系统换页；匿名换页）
###9.1.3.按需换页
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/%E6%8C%89%E9%9C%80%E8%B0%83%E9%A1%B5%E7%AE%97%E6%B3%95.png)
###9.1.4.过度提交
###9.1.5.交换：主存在物理交换设备或者交换文件之间移动整个进程
###9.1.6.文件系统缓存占用
###9.1.7.使用率和饱和度
###9.1.8.分配器
###9.1.9.字长
##9.2.内存管理单元（MMU）
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8D%95%E5%85%83.png)
##9.3.进程地址空间
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4.png)
##9.4.分配器（slab）
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8.png)
##9.5.调优
###9.5.1.可调参数
![](https://i.imgur.com/PplCreQ.png)
###9.5.2.多个页面大小：更大的页面能通过提高TLB缓存命中率来提升内存I/O性能
###9.5.3.资源控制（主存限制与虚拟内存限制）

#十.文件系统
##10.1.基本概念
###10.1.1.文件系统延时
###10.1.2.缓存
###10.1.3.随机与顺序I/O
###10.1.4.预取/预读
###10.1.5.写回缓存
###10.1.6.同步写（单次同步写/同步提交已写内容）
###10.1.7.裸I/O与直接I/O
###10.1.8.内存映射文件（mmap/munmap）
###10.1.9.元数据（逻辑元数据、物理元数据）
###10.1.10.逻辑I/O vs 物理I/O
###10.1.11.操作并非不对等
###10.1.12.特殊文件系统
###10.1.13.访问时间戳
###10.1.14.容量
##10.2.文件系统栈
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%88.png)
##10.3.文件缓存
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BC%93%E5%AD%98.png)
##10.4.文件系统特性
###10.4.1.块与区段
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/%E5%9D%97%E5%92%8C%E5%8C%BA%E6%AE%B5.png)
###10.4.2.日志
###10.4.3.写时复制（1.把数据写到一个新块；2.更新引用指向新块；3.把老块放到空闲链表中）
###10.4.4.擦洗：在后台读出文件系统里所有的数据块。验证校验和。赶在RAID还能恢复数据前，在第一时间检测出坏盘
##10.5.文件系统类型
##10.6.调优
###10.6.1.应用程序调用
###10.6.2.ext3
###10.6.3.ZFS:支持大量文件系统级别的可调参数，以及少量系统级别的参数

#十一.磁盘
##11.1.基本概念
###11.1.1.测量时间（服务时间、等待时间，计算时间）
###11.1.2.时间尺度
###11.1.3.缓存
###11.1.4.随机 vs 连续I/O
###11.1.5.读/写比
###11.1.6.I/O大小
###11.1.7.IOPS并不平等
###11.1.8.非数据传输磁盘命令
###11.1.9.使用率
###11.1.10.饱和度
###11.1.11.I/O等待
###11.1.12.同步 vs 异步
###11.1.13.磁盘 vs 应用程序I/O
##11.2.架构
##11.3.调优
###11.3.1.操作系统可调参数
###11.3.2.磁盘设备可调参数
###11.3.3.磁盘控制器可调参数

#十二.网络
##12.1.基本概念
###12.1.1.网络与路由
###12.1.2.协议
###12.1.3.封装
###12.1.4.包长度：网络接口的最大传输单元
###12.1.5.延时（主机名解析延时；ping延时；连接延时；首字节延时；往返时间；连接生命周期）
###12.1.6.缓冲
###12.1.7.连接积压队列
###12.1.8.接口协商
###12.1.9.使用率
###12.1.10.本地接口
##12.2.TCP
###12.2.1.三次握手
###12.2.2.重复确认检测：快速重传输和快速恢复
###12.2.3.阻塞控制（Reno和Tahoe）
###12.2.4.Nagle算法：通过推迟小尺寸包的传输以减少网络中的这些包的数量，从而使更多的数据能够到达和合并。仅当数据进入数据通道并且已经发生延时时，才会推迟数据包
###12.2.5.延时ACK
##12.3.UDP
##12.4.通用IP网络栈
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/%E9%80%9A%E7%94%A8IP%E7%BD%91%E7%BB%9C%E6%A0%88.png)
##12.5.调优
###12.5.1.套接字和TCP缓冲
###12.5.2.TCP积压队列
###12.5.3.设备积压队列
###12.5.4.TCP阻塞控制
###12.5.5.TCP选项
###12.5.6.配置（以太网巨型帧；链路聚合；套接字选项）



#十三.提高系统的并发能力
##13.1.垂直扩展、水平扩展
##13.2.分层水平扩展
###13.2.1.反向代理层的水平扩展：是通过“DNS轮询”实现的：dns-server对于一个域名配置了多个解析ip，每次DNS解析请求来访问dns-server，会轮询返回这些ip。
###13.2.2.站点层的水平扩展：站点层的水平扩展，是通过“nginx”实现的。通过修改nginx.conf，可以设置多个web后端。
###13.2.3.服务层的水平扩展：通过“服务连接池”实现的
###13.2.4.数据层的水平扩展（范围拆分；哈希拆分；）：

#十四.系统的高可用（冗余+自动故障转移）
##14.1.【客户端层->反向代理层】的高可用：keepalived存活探测，相同的virtual IP提供服务
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%B1%82-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%B1%82%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8.png)
##14.2.【反向代理层->站点层】的高可用
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%B1%82-%E7%AB%99%E7%82%B9%E5%B1%82%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8.png)
##14.3.【站点层->服务层】的高可用
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/%E7%AB%99%E7%82%B9%E5%B1%82-%E6%9C%8D%E5%8A%A1%E5%B1%82%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8.png)
##14.4.【服务层>缓存层】的高可用（客户端的封装，services对cache进行双写或者双读；主从同步的缓存集群）
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/%E6%9C%8D%E5%8A%A1%E5%B1%82-%E7%BC%93%E5%AD%98%E5%B1%82%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8.png)
##14.5.【服务层>数据库层】的高可用（主从同步，读写分离）

#十四.消息队列
##14.1.基本概念
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.png)
###14.1.1.消息生产者Producer：发送消息到消息队列。
###14.1.2.消息消费者Consumer：从消息队列接收消息
###14.1.3.Broker：概念来自与Apache ActiveMQ，指MQ的服务端，帮你把消息从发送端传送到接收端。
###14.1.4.消息队列Queue：一个先进先出的消息存储区域。消息按照顺序发送接收，一旦消息被消费处理，该消息将从队列中删除
##14.2.设计Broker的主要考虑（两次RPC加一次转储，如果要做消费确认，则是三次RPC。）
###14.2.1.消息的转储：在更合适的时间点投递，或者通过一系列手段辅助消息最终能送达消费机。
###14.2.2.规范一种范式和通用的模式，以满足解耦、最终一致性、错峰等需求。
###14.2.3.其实简单理解就是一个消息转发器，把一次RPC做成两次RPC。发送者把消息投递到broker，broker再将消息转发一手到接收端。
##14.3.点对点消息队列模型（每个消息只有一个消费者；发送者和接收者之间在时间上没有依赖性；接收者在成功接收消息之后需向队列应答成功）
##14.4.发布订阅消息模型Topic(每个消息可以有多个消费者;发布者和订阅者之间有时间上的依赖性;针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息;为了消费消息，订阅者必须保持运行的状态)
##14.5.消息的顺序性保证：FIFO
##14.6.消息的ACK机制
##14.7.最终一致性（记录和补偿）
##14.8.消息的持久化与高可用

##14.9.为什么使用消息队列
###14.9.1.解耦：通过一个MQ，Pub/Sub发布订阅消息这么一个模型，系统间就可以彻底解耦
###14.9.2.异步：
###14.9.3.削峰：

##14.10.消息队列的局限性
###14.10.1.系统的可用性降低：消息队列的高可用性
###14.10.2.系统复杂度提高（消息没有重复消费；消息丢失；消息传递的顺序性等问题）
###14.10.3.一致性问题

##14.11.不同消息队列的对比
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/Kafka%E3%80%81ActiveMQ%E3%80%81RabbitMQ%E3%80%81RocketMQ%20%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9.png)
#十五.空指针问题
###15.1.字符串比较，常量放在前面
###15.2.初始化默认值：在对象初始化的时候给它一个默认值或者默认构造实现
###15.3.返回空集合
###15.4.断言
###15.5.Optional

#十六.Java编写基本原则
##16.1.将一些需要变动的配置写在属性文件中
##16.2.测试中尽可能模拟线上环境
##16.3.对于所有外部调用以及内部服务都要做容错处理（不允许出现服务调用超时和重试，将会对应用程序的稳定性以及性能产生不利的影响）
##16.4.需要提供一下文档（编写单元测试文档并使其拥有良好的代码覆盖率；高层次的设计图：描述所有的组件、交互和结构；详细的设计图：具体到代码层面的设计；系统map：说明系统的所有组成文件、配置文件等）
##16.5.做好系统关键功能的监控、错误恢复、备份等
##16.6.数据库设计师设计一些便于追踪历史、整理的列
##16.7.制定好项目回滚计划
##16.8.项目上线前要做好量化分析（内存、数据库、文件、缓存等）
##16.9.选择合适的工具、技术
##16.10.在一些关键技术邻域具备充足的知识储备（设计模式、JVM调优、多线程"并发问题"、事务问题，包括分布式事务、性能问题，包括GC、计算等、缓存等等。）

#十七.Tomcat顶层架构
##17.1.Tomcat中只有一个Server，一个Server可以有多个Service，一个Service可以有多个Connector和一个Container；
##17.2.Server掌管着整个Tomcat的生死大权；
##17.3.Service 是对外提供服务的；
##17.4.Connector用于接受请求并将请求封装成Request和Response来具体处理；
##17.5.Container用于封装和管理Servlet，以及具体处理request请求；

#十八.异常处理原则
##18.1.不用使用异常来管理业务逻辑，应该使用条件语句。如果一个控制逻辑可通过 if-else 语句来简单完成的，那就不用使用异常，因为异常会降低代码的可读性和性能，例如一些 null 的判断逻辑、除0的控制等等；
##18.2.异常的名字必须清晰而且有具体的意思，表示异常发生的问题。
##18.3.当方法判断出错该返回时应该抛出异常，而不是返回一些错误值，因为错误值难以理解而且不够直观
##18.4.应该捕获指定的异常，而不是 catch(Exception e) 了事，这对性能、代码的可读性以及诸多方面都有好处
##18.5.Null 的判断逻辑并不是一成不变的，当方法允许返回 null 的时候使用 if-else 控制逻辑，否则就抛出 NullPointerException
##18.6.尽量不要二次抛出异常，如果非得这么做的话，抛出同一个异常示例，而不是重新构建一个异常对象，这对性能是有帮助的，而且外层调用者可获取真实的异常信息
##18.7.定义你自己的异常类层次，例如 UserException 和 SystemException 分别代表用户级别的异常信息和系统级别的异常信息，而其他的异常在这两个基类上进行扩展
##18.8.确的使用不同的异常类型
##18.9.不要仅仅捕获异常而不做任何处理，不便于将来维护
##18.10.不要多次重复记录同一个异常，这可以让我们清晰的了解异常发生的位置
##18.11.请使用 finally 来释放一些打开的资源，例如打开的文件、数据库连接等等
##18.12.大部分情况下不建议在循环中进行异常处理，应该在循环外对异常进行捕获处理
##18.13.异常的粒度很重要，应该为一个基本操作定义一个 try-catch 块，不要为了简便，将几百行代码放到一个 try-catch 块中
##18.14.为你的异常生成足够的文档说明，至少是 JavaDoc
##18.15.为每个异常消息定义一个数值，这对好的文档来说是非常重要的。

#十九.注解
##19.1.定义：元数据，即一种描述数据的数据。
##19.2.作用
###19.2.1.编写文档：通过代码里标识的元数据生成文档
###19.2.2.代码分析：通过代码里标识的元数据对代码进行分析
###19.2.3.编译检查：通过代码里标识的元数据让编译器能够实现基本的编译检查

#二十.性能优化
##20.1.尽量在合适的场合使用单例
###20.1.1.控制资源的使用，通过线程同步来控制资源的并发访问
###20.1.2.控制实例的产生，以达到节约资源的目的
###20.1.3.控制数据共享，在不建立直接联系的条件下，让多个不相关的进程或线程之间实现通信
##20.2.尽量避免随意使用静态变量
##20.3.尽量避免过多过常的创建Java对象
##20.4.尽量使用final修饰符
##20.5.尽量使用局部变量
##20.6.尽量处理好包装类型和基本类型两者的使用场所
##20.7.慎用synchronized，尽量减少synchronize的方法
##20.8.尽量使用StringBuilder和StringBuffer进行字符串连接
##20.9.尽量不要使用finalize方法
##20.10.尽量使用基本数据类型代替对象
##20.11.单线程应尽量使用HashMap、ArrayList
##20.12.尽量合理的创建HashMap
##20.13.尽量在finally块中释放资源
##20.14.尽量确定StringBuffer的容量
##20.15.尽量早释放无用对象的引用
##20.16.尽量避免使用二维数组
##20.17.尽量使用System．arraycopy（）代替通过来循环复制数组
##20.18.尽量缓存经常使用的对象
##20.19.尽量避免非常大的内存分配
##20.20.慎用异常

#二十一.倒排索引
##21.1.单词词典（Term Dictionary）(一般由B+Tree实现)
###21.1.1.记录所有文档的单词，一般比较大
###21.1.2.记录单词到倒排列表的关联信息
##21.2.倒排列表（Posting List）：记录单词对应的文档集合，由倒排索引项组成
###21.2.1.文档ID，用于获取原始信息
###21.2.2.单词频率，记录该单词在该文档中的出现次数，用于后续相关性算法分析
###21.2.3.位置，记录单词在文档中的分词位置，用于做词语搜索
###21.2.4.偏移，记录单词在文档的开始与结束位置，用于高亮显示

#二十二.一致性哈希算法（https://blog.csdn.net/losetowin/article/details/53743135）
##22.2.哈希算法好坏的原则（平衡性；单调性；分散性；负载）
##22.1.虚拟节点（解决雪崩问题）