#一.基本知识
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/Linux%E5%86%85%E6%A0%B8.png)
##1.1.进程
###1.1.1.fork:创建当前进程的一个副本。写时复制技术
###1.1.2.exec:将一个新程序加载到当前进程的内存中并执行
###1.1.3.命名空间
##1.2.虚拟地址空间（内核空间/用户空间）
##1.3.特权级别

##1.4.地址空间
###1.4.1.物理内存页称为页帧，虚拟地址空间称为页；将虚拟地址空间映射到物理地址空间的数据结构成为页表

###1.4.2.MMU(内存管理单元)优化内存访问操作；TLB（地址转换后备缓冲器）
##1.5.物理内存的分配
###1.5.1.伙伴系统
###1.5.2.slab缓存
###1.5.3.页面交换和页面回收:将磁盘空间作为扩展内存
##1.6.系统调用（用户态到内核态）
###1.6.1.进程管理
###1.6.2.信号
###1.6.3.文件
###1.6.4.目录和文件系统
###1.6.5.保护机制
###1.6.6.定时器函数
##1.7.字符设备和块设备
##1.8.网络
##1.9.文件系统
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.png)
##1.10.缓存：由于内核是通过基于页的内存映射来实现访问块设备的，因此缓存也按页组织，也就是说整页都缓存起来，故称为页缓存


#二.进程管理与调度
##2.1.创建进程：
###2.1.1.系统初始化
###2.1.2.执行了正在运行的进程所调用的进程创建系统调用
###2.1.3.用户请求创建一个新进程
###2.1.4.一个批处理作业的初始化
##2.2.进程与线程
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83.png)
##2.1.进程生命周期：
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/%E8%BF%9B%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png)
##2.2.进程管理
###2.2.1.进程复制（写时复制技术）
###2.2.2.内核线程
###2.2.3.启动新程序
###2.2.4.退出进程
##2.3.调度器（CFS调度器）
###2.3.1.吞吐vs响应（上下文切换）
###2.3.2.CPU消耗vsI/O消耗
###2.3.3.分配vs占据
###2.3.4.隔离vs共享
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%A4%9A%E8%BF%9B%E7%A8%8B.png)



#三.内存管理(https://www.jianshu.com/p/5d386ab54aac)
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.png)

#四.进程虚拟内存
##4.1.进程地址空间布局
###4.1.1.当前运行代码的二进制代码。该代码通常称之为text，所处的虚拟内存区域称之为text段
###4.1.2.程序使用的动态库的代码
###4.1.3.存储全局变量和动态产生的数据的堆
###4.1.4.用于保存局部变量和实现函数/过程调用的栈
###4.1.5.环境变量和命令行参数的段
###4.1.6.将文件内容映射到虚拟地址空间中的内存映射
##4.2.按需调页法
###4.2.1.进程试图访问用户地址空间中的一个内存地址，但使用页表无法确定物理地址
###4.2.2.处理器接下来触发一个缺页异常，发送到内核
###4.2.3.内核会检查负责缺页区域的进程地址空间数据结构，找到适当的后备存储器，或者确认该访问实际上是不正确的
###4.2.4.分配物理内存页，并从后备存储器读取所需数据填充
###4.2.5.借助于页表将物理内存页并入到用户进程的地址空间，应用程序恢复执行
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BC%93%E5%AD%98.png)


#五.锁与进程间的通信
##5.1.控制条件
###5.1.1.竞态条件
###5.1.2.临界区
###5.1.3.信号量
##5.2.解决临界区
###5.2.1.任何两个进程不能同时处于临界区
###5.2.2.不应对CPU的速度与数量做任何假设
###5.2.3.临界区外运行的进程不得阻塞其他进程
###5.2.4.不得使进程无限期等待进入临界区
##5.3.内核锁机制
###5.3.1.原子操作：
###5.3.2.自旋锁：它们用于短期保护某段代码，以防止其他处理器的访问。在内核等待自旋锁释放时，会重复检查是否能获取锁，而不会进入睡眠状态（忙等待）
###5.3.3.信号量：在等待信号量释放时，内核进入睡眠状态，直至被唤醒。唤醒后，内核才重新尝试获取信号量。 互斥量是信号量的特例，互斥量保护的临界区，每次只能有一个用户进入
###5.3.4.读者/写者锁
##5.4.内存和优化屏障（指令重排序）
##5.5.锁竞争与细粒度锁
##5.6.进程间通信
###5.6.1.信号量：由于信号量只能进行两种操作等待和发送信号，即P(sv)和V(sv),他们的行为是这样的：P(sv)：如果sv的值大于零，就给它减1；如果它的值为零，就挂起该进程的执行；    V(sv)：如果有其他进程因等待sv而被挂起，就让它恢复运行，如果没有进程因等待sv而挂起，就给它加1.

###5.6.2.消息队列
###5.6.3.共享内存：速度最快，效率最高的进程间通信方式，进程之间直接访问内存，而不是通过传送数据。但是使用共享内存需要自己提供同步机制
###5.6.4.信号：信号是在软件层次上对中断机制的一种模拟，在原理上，一个进程收到一个信号与处理器收到一个中断请求可以说是一样的。信号是异步的
###5.6.5.管道（无名管道/有名管道）：管道是由内核管理的一个缓冲区，相当于我们放入内存中的一个纸条。管道的一端连接一个进程的输出。这个进程会向管道中放入信息。管道的另一端连接一个进程的输入，这个进程取出被放入管道的信息。一个缓冲区不需要很大，它被设计成为环形的数据结构，以便管道可以被循环利用。当管道中没有信息的话，从管道中读取的进程会等待，直到另一端的进程放入信息。当管道被放满信息的时候，尝试放入信息的进程会等待，直到另一端的进程取出信息。当两个进程都终结的时候，管道也自动消失
###5.6.6.套接字

#六.虚拟文件系统
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.png)

#七.网络

#八.LVM：动态卷管理，可以将多个硬盘和硬盘分区做成一个逻辑卷，并把这个逻辑卷作为一个整体来统一管理，动态对分区进行扩缩空间大小，安全快捷方便管理
- 四个概念
	- PE(Physical Extend)：物理拓展
	- PV(Physical Volume):物理卷
	- VG(Volumn Group)：卷组
	- LV(Logical Volume):逻辑卷



- 特点：对磁盘进行动态管理。逻辑卷的大小可以动态调整的，而且不会出现丢失数据，若增加硬盘，其也不会改变现有上层的逻辑卷
- 原理
	- 物理磁盘被格式化为PV,空间被划分为一个个的PE
	- 不同的PV加入到同一个VG中，不同的PV的PE全部进入到VG的PE池内
	- LV基于PE创建，大小为PE的整数倍，组成LV的PE可能来自不同的物理磁盘  
	- LV现在就直接可以格式化后挂载使用了
	- LV的扩充缩减实际上就是增加或减少组成该LV的PE数量，其过程不会丢失原始数据

- 操作