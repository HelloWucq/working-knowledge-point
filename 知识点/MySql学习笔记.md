#一.基本知识
##1.组成：连接池组件；管理服务和工具组件；SQL接口组件；查询分析器组件；优化器组件；缓冲组件；插件式存储引擎；物理文件
##2.存储引擎是基于表的，而不是数据库
##3.通配符（1.%（任意字符出现任意次数）；2._单个字符）
##4.拼接字段Concat()函数
##5.WHERE在数据分组前进行过滤，HAVING在数据分组后进行过滤
##6.SELECT子句顺序（SELECT; FROM; WHERE; GROUP BY; HAVING; ORDER BY; LIMIT）
##7.子查询；相关子查询
##8.联结表
##9.自联结与子查询
##10.组合查询（在单个查询中从不同的表返回类似结构的数据；对单个表执行多个查询，按单个查返回结果）
##11.全文本搜索
##12.对UPDATE或DELETE使用WHERE子句前，应该先用SELECT进行测试，保证过滤的是正确的结果
##13.视图
##14.存储过程（1.把处理封装在容易使用的单元中，简化复杂的操作；2.不要求反复建立一系列的处理步骤，保证数据的完整性；3.简化对变动的管理；4.提高性能；5.高性能）
##15.使用游标：
##16.使用触发器：
##17.事务管理：
##18.权限管理：
##19.数据类型：
##20.索引建立（1.仅当出现清晰需求的时候才添加索引；2.装载数据前删除索引，然后在仓库开放营业前重建他们；3.主键和外键键索引，还有被频繁检索的列）
##21.聚集索引与非聚集索引
###21.1.1.聚集索引就是以主键创建的索引
###21.1.2.非聚集索引就是以非主键创建的索引
- 聚集索引在叶子节点存储的是表中的数据
- 非聚集索引在叶子节点存储的是主键和索引列
- 使用非聚集索引查询出数据时，拿到叶子上的主键再去查到想要查找的数据。(拿到主键再查找这个过程叫做回表)
##22.最左匹配原则
- 索引可以简单如一个列(a)，也可以复杂如多个列(a, b, c, d)，即联合索引。
- 如果是联合索引，那么key也由多个列组成，同时，索引只能用于查找key是否存在（相等），遇到范围查询(>、<、between、like左匹配)等就不能进一步匹配了，后续退化为线性查找。
- 因此，列的排列顺序决定了可命中索引的列数。


#二.详解
##2.1.数据类型：
###2.1.1.数字数据类型：1）INT:可以指定多达11位的宽度;2)TINYINT:可以指定多达4位数的宽度;3)可以指定最多5位的宽度;4)MEDIUMINT:可以指定最多9位的宽度;5)BIGINT:可以指定最多20位的宽度;6) FLOAT(M,D):可以定义显示长度(M)和小数位数(D);7)DOUBLE(M,D) ;8)DECIMAL(M,D);
###2.1.2.日期和时间类型:1)DATE： 以YYYY-MM-DD格式的日期，在1000-01-01和9999-12-31之间；2）DATETIME：日期和时间组合以YYYY-MM-DD HH:MM:SS格式，在1000-01-01 00:00:00 到9999-12-31 23:59:59之间；3）TIME：存储时间在HH:MM:SS格式；4）YEAR(M)：以2位或4位数字格式来存储年份；
###3.字符串类型：1）CHAR(M):固定长度的字符串是以长度为1到255之间个字符长度;2)VARCHAR(M)：可变长度的字符串是以长度为1到255之间字符数,必须定义长度。3）BLOB or TEXT：字段的最大长度是65535个字符。BLOB是“二进制大对象”，并用来存储大的二进制数据，如图像或其他类型的文件。定义为TEXT文本字段还持有大量的数据; 两者之间的区别是，排序和比较上存储的数据，BLOB大小写敏感，而TEXT字段不区分大小写。4）TINYBLOB 或 TINYTEXT：BLOB或TEXT列用255个字符的最大长度。5）MEDIUMBLOB or MEDIUMTEXT：BLOB或TEXT列具有16777215字符的最大长度；6）LONGBLOB 或 LONGTEXT：LOB或TEXT列具有4294967295字符的最大长度；7）ENUM:枚举



##2.2.SELECT语法：
`
	SELECT 
    	column_1, column_2, ...
	FROM
    	table_1
	[INNER | LEFT |RIGHT] JOIN table_2 ON conditions
	WHERE
    	conditions
	GROUP BY column_1
	HAVING group_conditions
	ORDER BY column_1
	LIMIT offset, length;
`
###2.2.1.WHERE过滤结果集中的行
###2.2.2.GROUP BY将一组行组合成小分组，并对每个小分组应用聚合函数
###2.2.3.HAVING过滤器基于GROUP BY子句定义的小分组



##2.3.INSERT语法：
    INSERT INTO table(column1,column2...) VALUES (value1,value2,...);
##2.4.UPDATE语法：
    UPDATE [LOW_PRIORITY] [IGNORE] table_name 
	SET 
    	column_name1 = expr1,
    	column_name2 = expr2,
    	...
	WHERE
    	condition;
##2.5.DELETE语法：
    DELETE FROM table_name
	WHERE condition;

#三.原理
##3.1.B树
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/B-tree%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B.png)
##3.1.B+树
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/B%2Btree%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B.png)
###3.1.1.只有最底层的节点（叶子节点）才保存信息（相关表的行位置）
###3.1.2.其它节点只是在搜索中用来指引到正确节点的。
###3.1.3.最底层的节点是跟后续节点相连接的
##3.2.索引
###3.2.1.不要使用太多索引，插入/更新/删除表中的一个行的操作（log(N)）；增加索引意味着给事务管理器带来更多的工作负荷
##3.3.核心组件：
###3.3.1.进程管理器（process manager）：很多数据库具备一个需要妥善管理的进程/线程池。
###3.3.2.网络管理器（network manager）：网路I/O是个大问题，尤其是对于分布式数据库。
###3.3.3.文件系统管理器（File system manager）：磁盘I/O是数据库的首要瓶颈。
###3.3.4.内存管理器（memory manager）：为了避免磁盘I/O带来的性能损失，需要大量的内存。
###3.3.5.安全管理器（Security Manager）：用于对用户的验证和授权。
###3.3.6.客户端管理器（Client manager）：用于管理客户端连接。
##3.4.工具
###3.4.1.备份管理器（Backup manager）：用于保存和恢复数据。
###3.4.2.复原管理器（Recovery manager）：用于崩溃后重启数据库到一个一致状态。
###3.4.3.监控管理器（Monitor manager）：用于记录数据库活动信息和提供监控数据库的工具。
###3.4.4.Administration管理器（Administration manager）：用于保存元数据（比如表的名称和结构），提供管理数据库、模式、表空间的工具。
##3.5.查询管理器：
###3.5.1.查询解析器（Query parser）：用于检查查询是否合法
###3.5.2.查询重写器（Query rewriter）：用于预优化查询
###3.5.3.查询优化器（Query optimizer）：用于优化查询
###3.5.4.查询执行器（Query executor）：用于编译和执行查询
##3.6.数据管理器
###3.6.1.事务管理器（Tra****nsaction manager）：用于处理事务
###3.6.2.缓存管理器（Cache manager）：数据被使用之前置于内存，或者数据写入磁盘之前置于内存
###3.6.3.数据访问管理器（Data access manager）：访问磁盘中的数据
##3.7.事务的ACID
###3.7.1.原子性（Atomic）:数据库事务是不可分割的工作单位
###3.7.2.一致性（Consistency）：指数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性
###3.7.3.隔离性（Isolation）：指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间
###3.7.4.持久性：指的是只要事务成功结束，它对数据库所做的更新就必须永久保存下来。即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态

##3.8.数据库的隔离级别：
###3.8.1.读未提交（Read uncommitted）：出现脏读情况；两个并发的事务，事务B读取了事务A尚未提交的数据
###3.8.2.读提交（Read committed ）：出现不可重复读；两个并发的事务，事务A事先读取了数据，事务B紧接着更新了数据，并提交了事务，而事务A再次读取该数据时，数据已经发生了改变
###3.8.3.重复读（Repeatable read）：出现幻读；
###3.8.4.序列化（Serializable）


#四.InnoDB技术原理详解
##4.1.体系架构
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/InnoDB%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84.png)
##4.2.后台线程：多线程模型，负责处理不同的任务
###4.2.1.Master Thread:负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性
###4.2.2.IO Thread:使用了AIO来处理写IO请求，IO Thread主要负责这些IO请求的回调处理
###4.2.3.Purge Thread:回收已经使用并分配的undo页
###4.2.4.Page Cleaner Thread:脏页的刷新操作放到单独的线程完成
##4.3.内存：基于磁盘存储的，并将其中的记录按照页的方式进行管理
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/InnoDB%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1.png)
###4.3.1.缓冲池：
###4.3.2.LRU List,Free List和Flush List:管理内存区域
###4.3.3.重做日志缓冲：
###4.3.4.额外的内存池：对内存的管理通过一种称为内存堆的方式进行，对一些数据结构本身的内存进行分配时，需要从额外的内存池中进行申请，当该区域的内存不够时，会从缓冲池中进行申请。
##4.4.Checkpoint技术：
###4.4.1.针对的问题：1）缩短数据库的恢复时间；2）缓冲池不够用时，将脏页刷新到磁盘；3）重做日志不可用时，刷新脏页
###4.4.2.Sharp Checkpoint/Fuzzy Checkpoint:
##4.5.Master Thread:
##4.6.关键特性：
###4.6.1.插入缓冲：对于非聚集索引的插入或更新操作，不是每一次直接插入到索引页，而是先判断插入的非聚集索引页是否在缓冲池中，若在，则直接插入，若不在，则先放入到一个Insert Buffer对象中（1）条件：1）索引是辅助索引；2）索引不是唯一的
###4.6.2.两次写（部分写导致失效）：保证数据页的可靠性
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/%E4%B8%A4%E6%AC%A1%E5%86%99%E6%9E%B6%E6%9E%84.png)
###4.6.3.自适应哈希索引：自动根据访问的频率与模式来自动的为某些热点页建立哈希索引
###4.6.4.异步IO
###4.6.5.刷新邻接页：对于传统的机械硬盘建议开启该项功能，对于固态硬盘有着超高的IOPS性能的磁盘，建议将该参数设置为0，即关闭该特性
##4.7.InnoDB页结构
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/InnoDB%E9%A1%B5%E7%BB%93%E6%9E%84.png)
###4.7.1.各个数据页可以组成一个双向链表
###4.7.2.每个数据页中的记录可以组成一个单向链表

#五.文件
##5.1.参数文件：告诉MySQL实例启动时在哪里可以找到数据库文件，并且指定某些初始化参数，这些参数定义了某种内存结构的大小设置，还会介绍各种参数的类型
##5.2.日志文件（错误日志；二进制日志；慢查询日志；查询日志）
##5.3.套接字文件
##5.4.pid文件：
##5.5.表结构定义文件
##5.6.InnoDB存储引擎文件
###5.6.1.表空间文件：
###5.6.2.重做日志文件

#六.表
##6.1.逻辑存储结构：
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/InnoDB%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png)
###6.1.1.表空间：存放的只是数据、索引和插入缓冲Bitmap页，其他类的数据还是存放在原来的共享表空间内
###6.1.2.段：数据段；索引段；回滚段
###6.1.3.区：有连续页组成，在任何情况下每个区大小都为1MB
###6.1.4.页：磁盘管理的最小单位
###6.1.5.行：行记录格式（Compact/Redundant）

##6.2.数据页结构：
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84.png)
##6.3.约束：
##6.4.视图（被用作一个抽象装置，对于一些应用程序，程序本身不需要关心基表的结构，只需要按照视图定义来取数据或更新数据）：命名的虚表，视图中的数据没有实际的物理存储
##6.5.分区表：（RANGE分区；LIST分区；HASH分区；KEY分区）

#七.索引与算法
##7.1.B+树索引
###7.1.1.聚集索引：按照每张表的主键构造一课B+树，同时叶子节点中存放的即为整张表的行记录数据，将聚集索引的叶子节点称为数据页；每张表只能拥有一个聚集索引
###7.1.2.非聚集索引：叶子节点并不包含行记录的全部数据，叶子节点除了包含键值外，每个叶子节点中的索引行还包含一个书签，该书签告诉InnoDB哪里可以找到与索引相对应的行数据
##7.2.Cardinality值（索引中不重复记录数量的预估值）
##7.3.哈希算法
##7.4.全文检索
###7.4.1.倒排索引：


#八.锁
##8.1.lock与latch的区别
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/Lock%E4%B8%8Elatch%E7%9A%84%E5%8C%BA%E5%88%AB.png)
##8.2.锁类型：行级锁（共享锁；排它锁）
##8.3.锁算法：（Record Lock/Gap Lock/Next-Key Lock）
##8.4.锁问题（脏读；不可重复读；丢失更新）
##8.5.阻塞：
##8.6.死锁：（1）超时机制；2）wait-for graph死锁检测机制）
##8.7.锁升级

#九.事务
##9.1.事务的实现
###9.1.1.redo log（保证事务的原子性和持久性）：通常是物理日志，记录的是页的物理修改操作
###9.1.2.undo log(保证事务的一致性)：逻辑日志，根据每行记录进行记录
##9.2.事务控制语句
##9.3.事务操作的统计
###9.3.1.每秒请求数（QPS）
###9.3.2.每秒事务处理的能力（TPS）
##9.4.分布式事务：使用分布式事务时，InnoDB的事务隔离级别必须设置为SERIALIZABLE
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%A8%A1%E5%9E%8B.png)
##9.5.不好的事务习惯：
###9.5.1.在循环中提交
###9.5.2.使用自动提交
###9.5.3.使用自动回滚
##9.6.长事务：通过小批量事务处理机制来解决长事务带来的问题
#十.备份与恢复
##10.1.备份的分类：
###10.1.1.备份方法（热备；冷备；温备）
###10.1.2.备份后的文件内容（逻辑备份；裸文件备份）
###10.1.3.备份数据库的内容（完全备份；增量备份；日志备份）
##10.2.复制：
###10.2.1.步骤：1）主服务器把数据更改记录到二进制日志中；2）从服务器把主服务器的二进制日志复制到自己的中继日志中；3）从服务器重做中继日志中的日志，把更改应用到自己的数据库上，以达到数据的最终一致性
![](https://i.imgur.com/ocGyxki.png)
![](https://i.imgur.com/9qtRPDW.png)


#十一.性能调优：[https://www.jianshu.com/p/fb1c16777851](https://www.jianshu.com/p/fb1c16777851 "数据库调优策略")
##11.1.RAID(独立磁盘冗余数组)
###11.1.1.作用：1）增强数据的集成度；2）增强容错功能；3）增加处理量或容量
##11.2.[http://www.hack520.com/169.html](http://www.hack520.com/169.html "RAID")
##11.3.MySQL查询过程
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/MySQL%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B.png)
##11.4.数据库优化维度
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E7%BB%B4%E5%BA%A6.png)
#注意事项
###1.存储引擎是基于表的，而不是数据库
###2.约束更是一个逻辑的概念，用来保证数据的完整性，而索引是一个数据结构，既有逻辑上的概念，在数据库中还代表着物理存储的方式
###3.数据库的应用分类：1）OLTP(在线事务处理)；2）OLAP(在线分析处理)
###4.B+树索引能找到的只是被查找数据行所在的页，然后数据库通过把页读入到内存，再在内存中进行查找，最后得到要查找的数据

#十二.基本架构
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/MySQL%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84.png)
##12.1.查询流程
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/MySQL%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B.png)

#十三.基本知识
##13.1.索引的目的：在大数据量的查询中提升查询速度,避免全表扫描
##13.2.什么样的信息可以成为索引：过滤性好的字段
##13.3.密集索引与稀疏索引的区别
###13.3.1.密集索引文件中的每个搜索码值都对应一个索引值
###13.3.2.稀疏索引文件只为索引码的某些值建立索引项
###13.3.3.innodb是密集索引,MyIsam是稀疏索引

#十四.补充知识点
##14.1.覆盖索引
- 
##14.2.最左匹配原则

#十五.索引
##15.2.实现上
- 聚集索引
- 非聚集索引
##15.1.功能上：
- 普通索引：最基本的索引，没有任何约束
- 唯一索引：与普通索引类似，但具有唯一性约束
- 主键索引：特殊的唯一索引，不允许有空值
- 复合索引：将多个列组合在一起创建索引，可以覆盖多个列
- 外键索引：只有InnoDB类型的表才可以使用外键索引，保证数据的一致性、完整性和实现级联操作
- 全文索引：MySQL自带的全文索引只能用于InnoDB、MyISAM,并且只能对英文进行全文索引
- 索引的设计
	- MySql 的主键不能太大，如果使用 UUID 这种，将会浪费 B+ 树的非叶子节点
	- MySql 的主键最好是自增的，如果使用 UUID 这种，每次插入都会调整 B+树，从而导致页分裂，严重影响性能

#十六.锁
##16.1.类型维度
- 共享锁（读锁 / S 锁）
- 排它锁（写锁 / X 锁）
- 悲观锁
- 乐观锁（使用版本号字段，类似 CAS 机制，即用户自己控制。缺点：并发很高的时候，多了很多无用的重试）
##16.2.锁的粒度
- 表锁
- 页锁
- 行锁