#一：基本知识与原则（[https://juejin.im/post/5c8756e6e51d456cda2e7ff1](https://juejin.im/post/5c8756e6e51d456cda2e7ff1)）

##1.目的原则

	创建型模式：与对象的创建有关

	结构型模式：处理类与对象的组合

	行为型模式：类与对象怎样交互和怎样分配职责进行描述


##2.范围原则（用于类还是对象）

类模式处理类与子类之间的关系，这些关系通过继承建立，是静态的，在编译时刻边确定下来。对象模式处理对象间的关系，这些关系在运行时刻可以变化，具有动态性

	类范围（Factory Method;  Adapter;  Interpreter,Template Method  ）

###（1）创建型类模式将对象的部分创建工作延迟到子类，而创建型对象模式则将他延迟到另一个对象中

###（2）结构型类模式使用继承机制组合类，而结构型对象模式描述了对象的组装方式

###（3）行为型类模式使用继承描述算法与控制流，而行为型对象模式描述一组对象怎样协作完成单个对象无法完成的任务


##3.针对接口编程而不是针对实现编程
###（1）客户无须知道他们使用对象的特定类型，只须对象有客户所期望的接口；
###（2）客户无须知道他们使用的对象是用什么类来实现的，只须知道定义的接口

##4.优先使用对象组合而不是类继承


#二：创建型模式  对一组固定行为的硬编码转移为定义一个较小的基本行为集，这些行为可以被组合成任意数目的更复杂的行为

##1.特点
###（1）关于系统使用哪些具体的类的信息封装起来
###（2）隐藏了这些类的实例是如何被创建和放在一起的，整个系统关于这些对象所知道的是由抽象类定义的接口

##2.抽象工厂
###(1）意图：提供一个创建一系列相关或相互依赖对象的接口，无须指定他们具体的类
###(2) 动机：
###(3) 适用性：一个系统要独立于它的产品的创建、组合以及表示时；一个系统要有多个产品系列中的一个来配置时；强调一系列相关产品对象的设计以便进行联合使用时；提供一个产品类库，只想显示他们的接口而不是实现
###(4) 结构
###(5) 核心组件：AbstractFactory(声明一个创建抽象产品对象的操作接口)；ConcreteFactory(实现创建具体对象的操作)；AbstractProduct(为一类产品对象声明一个接口)；ConcreteProduct(定义一个将被相应的具体工厂创建的产品对象)；Client(仅使用由AbstractFactory和AbstractProduct类声明的接口)
###(6)AbstractFactory将产品对象的创建延迟到他的ConcreteFactory子类
###(7)分离了具体的类；使得易于交换产品系列；有利于产品的一致性；难以支持新种类的产品

##3.生成器
###(1) 意图：将一个复杂对象的构建与他的表示分离
###(2) 动机：
###(3）适用性：创建复杂对象的算法应该独立于该对象的组成部分以及他们的转配方式；构造过程必须允许被构造的对象有不同的表示时
###（4）结构
###（5）核心组件：Builder(为创建一个Product对象的各个部分指定抽象接口)；ConcreteBuilder(实现Builder的接口以构造和装配该产品的各个部分，定义并明确它所创建的表示，提供一个检索产品的接口)；Director(构造一个使用Builder接口的对象)；Product(表示被构造的复杂对象，包含定义组成部分的类，包括将这些部件装配成最终产品的接口)
###（6）可以改变一个产品的内部表示；将构造代码与表示代码分开；对构造过程进行精细的控制

##4.工厂方法
###（1）意图：定义一个用于创建对象的接口，让子类决定实例化哪个类
###（2）动机
###(3)适用性：当一个类不知道他所必须创建的对象的类的时候；一个类希望由它的子类来指定它所构建的对象；类将创建对象的职责委托给多个帮助子类中的某一个，并且希望将哪一个帮助子类是代理则这一信息局部化的时候
###（4）结构
###（5）核心组件：Product（定义工厂方法所创建的对象的接口）;ConcreteProduct（实现Product接口）;Creator（声明工厂方法，返回一个Product类型的对象，调用工厂方法创建Product对象）；ConcreteCreator(重定义工厂方法以返回一个ConcreteProduct实例)

##5.原型方法
###（1）意图：用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象
###（2）动机
### (3) 适用性：系统独立于它的产品创建构成与表示时；实例化的类是在运行时刻指定的（动态装载);避免创建一个与产品类层次平行的工厂类层次；一个类的实例只能有几个不同的组态组合中的一种时
###（4）结构
### (5)核心组件：Prototype(声明一个克隆自身的接口)；ConcretePrototype(实现克隆自身的操作);Client(让一个原型克隆自身从而创建一个新的对象)
	
##6.单例模式
###（1）意图：保证一个类只有一个实例，并提供一个访问他的全局访问点
###（2）动机
###（3）适用性：类只能有一个实例；唯一实例应该是通过子类化可扩展的，并且无须修改代码就能使用一个扩展的实例
###（4）结构
###（5）核心组件：Singleton(定义一个Instance操作允许客户访问他的唯一实例，负责创建他自己的唯一实例)
###（6）特点

##7.总结


#三：结构型模式

##1.适配器模式

###(1)意图：将一个类的接口转换成客户希望的另外的一个接口。
###（2）动机
###（3）适用性：使用一个已经存在的类，而其接口不符合需求；创建一个可以复用的类，该类可以与其他不相关的类协同工作；对象适配器可以适配它的父类接口
###（4）结构
###（5）核心组件：Target(定义client使用的与特定邻域相关的接口)；Client(与符合Target接口的对象协同)；Adaptee(与Adaptee的接口与target接口适配)

##2.桥接模式
###（1）意图：将抽象部分与他的实现部分分离，使其都可以独立的变化
###（2）动机:处理多维度的变化
###（3）适用性：希望程序运行时刻实现部分可以被选择或者切换；类的抽象以及他的实现都应该可以通过生成子类的方法进行扩充；对一个抽象的实现部分的修改应对客户不产生影响；多个对象间实现共享
###（4）结构
###（5）核心组件：Abstraction（定义抽象类的接口，维护一个指向Implementor类型对象的指针）；RefinedAbstraction(扩充Abstraction定义的接口);Implementor(定义实现类的接口，Implementor接口仅提供基本操作，而Abstraction定义基于这些基本操作的较高层次的操作)；ConcreteImplementor(实现Implementor接口并sing一它的具体实现)
###（6）特点：实现接口及其实现分离；提高可扩充性；实现细节对客户透明

##3.组合模式
###（1）意图：将对象组合成树形结构以表示“整体-部分”的层次结构。从而用户对单个对象和组合对象的使用具有一致性。
###（2）动机
###（3）适用性：想表示对象间的层次关系；用户希望将统一的使用组合结构中的所有对象
###（4）结构
###（5）核心组件：Component(为组合中的对象声明接口；在适当的情况下，实现所有类共有接口的缺省行为；声明一个接口用于访问和管理Component的子组件);Leaf(在组合中表示叶节点对象；在组合中定义图元对象的行为)；Composite(定义有子部件的那些部件的行为，存储子部件，在Component接口中实现与子部件有关的操作)；Client(通过Component接口操纵组合部件的对象)。

##4.装饰者模式
###（1）意图：动态的给一个对象添加一些额外的职责。
###（2）动机
###（3）适用性：动态，透明的给单个对象添加职责；处理那些可以撤销的职责；不能采用生成子类的方法进行扩充时。
###（4）结构
###（5）核心组件：Component(定义一个对象的接口，给这些对象动态的添加职责)；ConcreteComponent(定义一个对象，可以给这些对象添加一些职责)；Decorator(维持一个指向Component对象的指针，并定义一个与Component接口一致的接口)；ConcreteDecorator(向组件添加职责)。
###（6）特点：比静态继承更加灵活；避免在层次结构高层的类有太多的特征；产生许多小对象


##5.外观模式
###（1）意图：为子系统中的一组接口提供一个一致的界面
###（2）动机
###（3）适用性：为一个复杂子系统提供一个简单接口；客户程序与抽象类的实现部分存在很大的依赖性；构建一个层次结构的子系统
###（4）结构
###（5）核心组件：Facade(知道哪些子系统类负责处理请求；将客户的请求代理给适当的子系统对象)；Subsystem classes（实现子系统的功能，处理Facade对象指派的任务,没有facade的任何相关信息）。
###（6）通常Facade对象属于Singleton

##6.享元模式
###（1）意图：运用共享技术有效的支持大量细粒度的对象
###（2）动机：内部状态与外部状态
###（3）适用性：一个程序使用了大量的对象；存储开销很大时；对象的大多数状态都可以变为外部状态；应用程序不依赖对象的标识
###（4）结构
###（5）核心组件：Flyweight(描述一个接口，通过这个接口flyweight可以接受并作用于外部状态)；ConcreteFlyweight(实现Flyweight接口，并为内部状态增加存储空间)；UnsharedConcreteFlyweight；Client(维持一个对flyweightd的引用，计算或存储一个或多个flyweight的外部状态)
###（6）空间上节约了存储，时间上回有一定的损失


##7.代理模式
###（1）意图：为其他对象提供一种代理以控制对这个对象的访问
###（2）动机：对一个对象进行控制访问是为了只有在我们确实需要这个对象是才对他进行创建和实例化
###（3）适用性：需要比较通用和复杂的对象的指针代替简单的指针的时候。
###（4）结构
###（5）核心组件：Proxy(保存一个引用使得代理可以访问实体；提供一个与Subject的接口相同的接口，从而代理就可以用来代替实体；控制对实体的存取，创建与删除)；Subject(定义RealSubject与Proxy的公用接口，从而任何使用RealSubject的地方都可以使用Proxy)；RealSubject(定义Proxy代表的实体)。


#三：行为模式（算法和对象间职责的分配，不仅描述对象或类的模式，还描述他们之间的通信模式）
##1.职责链模式
###(1)意图：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合。
###（2）动机：
###（3）适用性：有多个的对象可以处理一请求，哪个对象处理该请求运行时自动确定；不明确指定接收者的情况下，向多个对象中的一个提交请求；处理一个请求的对象集合应被动态指定。
###（4）结构
###（5）核心组件：Hander(定义一个处理请求的接口，实现后继链)；ConcreteHandler(处理它负责的请求；可访问他的后继者；如果有请求则处理，没有则转发给后继者);Client(向链上的具体处理者对象提交请求)。
###（6）特点：降低耦合度；增强了给对象指派职责的灵活性；不保证被接收。

##2.命令模式
###(1)意图：将一个请求封装成对象。从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。
###（2）动机：
###（3）适用性：抽象出待执行的动作以参数化某对象（是回调机制的一个面向对象的替代品）；在不同的时刻指定，排列和执行请求；支持取消操作；支持修改日志；用构建在原语操作上的高层操作构造一个系统。
###（4）结构
###（5）核心组件：Command(声明执行操作的接口)；ConcreteCommand(将一个接收者对象绑定与一个动作；调用接收者相应的操作，以实现Execute);Client(创建一个具体命令对象并设定它的接收者)；Invoker(要求该命令执行这个请求)；Receiver（知道如何实施与执行一个请求相关的操作）

##3.解释器模式
###(1) 意图：给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。
###（2）动机：
###（3）适用性：该文法简单对于复杂的文法，文法的类层次变得庞大而无法管理。
###（4）结构
###（5）核心组件：

##4.迭代器模式
###(1)意图：提供一种方法顺序访问一个聚合对象中的各个元素，而不暴露该对象的内部表示。
###（2）动机：
###（3）适用性：访问一个聚合对象的内容而无需暴露其内部表示；支持对聚合对象的多种遍历；为遍历不同的聚合结构提供一个统一的接口。
###（4）结构
###（5）核心组件：Iterator(迭代器定义访问和遍历元素的接口)；ConcreteIterator(具体迭代器实现迭代器接口；对该聚合遍历是跟踪当前位置)；Aggregate（聚合定义创建相应迭代器对象的接口）；ConcreteAggregate(具体聚合实现创建相应迭代器的接口)

##5.中介者模式
###(1)意图：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显示的相互引用，从而使其耦合松散，而且独立的改变它们之间的交互
###（2）动机：
###（3）适用性：一组对象以定义良好但是复杂的方式进行通信；一个对象引用其他许多对象并直接与这些对象通信，导致难以复用该对象；想定制一个分布在多个类中的行为，不想生成太多的子类
###（4）结构
###（5）核心组件：Mediator(定义一个接口用于与各同事对象通信)；ConcreteMediator(具体中介者通过协调各同事对象实现协作行为；了解并维护它的各个同事)；Colleague class(每一个同事类都知道它的中介者对象，每一个同事对象在需要和其他的同事通信是与它的中介者通信)。

##6.备忘录模式
###(1)意图：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原先保存的状态。
###（2）动机：
###（3）适用性：必须保存一个对象在某一个时刻的状态，这样以后需要才能恢复到原先的状态；如果一个用接口来让其他对象直接得到这些状态，将会暴露对象的实现细节。
###（4）结构
###（5）核心组件：Memento(备忘录存储原发器对象的内部状态；防止原发器以外的对象访问备忘录)；Originator(原发器创建一个备忘录，用以记录当前时刻它的内部状态；使用备忘录恢复内部状态)；Caretaker(负责保存好备忘录；不能对备忘录的内容进行操作或检查)。
###（6）特点：保持封装边界；简化了原发器；使用备忘录可能代价较高；定义窄接口和宽接口；维持备忘录的潜在代价。

##7.观察者模式
###(1)意图：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都得到通知并自动更新。
###（2）动机：
###（3）适用性：当一个抽象模型有两个方面，其中一个方面依赖于另一个方面；当对一个对象个改变需要同时改变其他对象，而不知道具体有多少对象有待改变。
###（4）结构
###（5）核心组件：Subject（目标知道其观察者；提供注册和删除观察者对象的接口);Observer(为那些在目标发生改变时需获得通知的对象定义一个更新接口)；ConcreteSubject(将有关状态存入各ConcreteObserver对象；当他的状态发生改变时，向他的各个观察者发出通知)；ConcreteObserver（维护一个指向ConcreteSubject对象的引用，存储有关状态，这些状态与目标的状态保持一致；实现Observer的更新接口以使自身状态的目标的状态保持一致）。
###（6）特点：目标与观察者间的抽象耦合；支持广播通信；意外的更新。

##8.状态模式
###(1)意图：允许一个对象在其内部状态发生改变时改变它的行为，对象似乎修改了它的类。
###（2）动机：
###（3）适用性：一个对象的行为取决于它的状态，并必须在运行时根据状态改变行为；一个操作中含有庞大的分支条件语句，且这些分支依赖于对象的状态
###（4）结构
###（5）核心组件：Context(定义用户感兴趣的接口；维护一个ConcreteState子类的实例，这个实例定义当前状态)；State(定义一个接口封装与Context的一个特定状态相关的行为)；ConcreteState subclasses(每一个子类实现一个与Context的一个状态相关的行为)。
###（6）特点：特定状态相关的行为局部化，并且将不同状态的行为分割开来；使得状态转化显式化；state对象可被共享。

##9.策略模式
###(1)意图：定义一系列的算法，并将其一个个的封装起来。使其可以相互替换。
###（2）动机：
###（3）适用性：许多相关的类仅仅是行为有异；需要使用一个算法的不同变体；算法使用客户不应该知道的数据；一个类定义了多种行为。
###（4）结构
###（5）核心组件：Strategy(定义所有支持的算法的公共接口，Context使用这个接口来调用其ConcreteStategy)；ConcreteStategy(实现Stategy接口的具体算法);Context(用一个ConcreteStrategy对象来配置；维护一个对Strategy对象的引用；定义一个接口来让Stategy访问其数据)。
###（6）特点：相关算法系列；一个替代继承的方法；消除一些条件语句；实现的选择；用户必须了解不同的strategy;Strategy与Context之间的通信开销；增加了对象的数目。

##10.模板方法模式
###(1)意图：定义一个操作中的算法骨架，将一些步骤延迟到其子类中。
###（2）动机：
###（3）适用性：一次性实现一个算法不变的部分，将可变的行为留给子类来实现；控制子类的扩展。
###（4）结构
###（5）核心组件：AbstractClass(定义抽象的原语操作，具体的子类将重定义他们以实现一个算法的各步骤；实现一个模板方法，定义一个算法的骨架)；ConcreteClass(实现原语操作以完成算法中与特定子类相关的步骤)。

##11.访问者模式
###(1)意图：表示一个作用于某个对象结构中的各元素的操作，使在不改变各元素的类的前提下定义作用于这些元素的新操作。
###（2）动机：
###（3）适用性：一个对象结构包含许多类对象，它们有不同的接口，而对这些对象实施一些依赖于其具体类的操作；需要对一个对象结构中的对象进行许多不同且不相关的操作；定义对象结构的类很少改变。
###（4）结构
###（5）核心组件：Visitor(为该对象结构中ConcreteElement的每一个类声明一个Visit操作)；ConcreteVistor(实现每个有Visitor声明的操作);Element(定义一个Accept操作以一个访问者为参数)；ConcreteElement(实现Accept操作，该操作以访问者为参数)；ObjectStructre（能枚举它的元素；可以提供一个高层的接口以允许该访问者访问其元素；可以是一个复合或是集合）。



	




