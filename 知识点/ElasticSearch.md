#一.基础介绍及索引原理分析（[https://www.cnblogs.com/dreamroute/p/8484457.html](https://www.cnblogs.com/dreamroute/p/8484457.html)）
##1.1.基本概念
- ElasticSearch是面向文档的，意味着它存储整个对象或文档，不仅存储文档，而且索引每个文档的内容使其可以被检索

#二.原理介绍

#三.集群内的原理
##3.1.空集群
- 一个运行中的 Elasticsearch 实例称为一个 节点，而集群是由一个或者多个拥有相同 cluster.name 配置的节点组成， 它们共同承担数据和负载的压力。
- 当一个节点被选举成为 主 节点时， 它将负责管理集群范围内的所有变更，例如增加、删除索引，或者增加、删除节点等。 而主节点并不需要涉及到文档级别的变更和搜索等操作，所以当集群只拥有一个主节点的情况下，即使流量的增加它也不会成为瓶颈。 任何节点都可以成为主节点。我们的示例集群就只有一个节点，所以它同时也成为了主节点。
##3.2.集群健康
###status字段
- green:所有的主分片和副本分片都正常运行。 
- yellow:所有的主分片都正常运行，但不是所有的副本分片都正常运行。 
- red:有主分片没能正常运行。 
##3.3.添加索引
###索引：指向一个或者多个物理分片的逻辑命名空间


- 一分片是一个底层的工作单元，仅保存了全部数据中的一部分
- 分片将数据分发到集群内各处。分片是数据的容器，文档保存在分片内，分片有被分配在集群内的各个节点里，Elasticsearch会自动在各节点中迁移分片
-  一个分片可以是 主 分片或者 副本 分片。 索引内任意一个文档都归属于一个主分片，所以主分片的数目决定着索引能够保存的最大数据量。
##3.4.故障转移
##3.5.水平扩容以及数据保障
#四.文档
- 最顶层或者根对象, 这个根对象被序列化成 JSON 并存储到 Elasticsearch 中，指定了唯一 ID。
##4.1.文档元数据
- _index：文档在哪存放
- _type:文档表示的对象类别
- _id:文档唯一标识
##4.2.文档的增删改查
##4.3.处理冲突：乐观并发控制
- version版本控制
##4.4.批量获取

#五.分布式文档存储
##5.1.路由一个文档到一个分片中
    shard = hash(routing) % number_of_primary_shards
- 建索引的时候就确定好主分片的数量 并且永远不会改变这个数量：因为如果数量变化了，那么所有之前路由的值都会无效，文档也再也找不到了。
##5.2.主分片和副本分片如何交互
- 我们可以发送请求到集群中的任一节点。 每个节点都有能力处理任意请求。 每个节点都知道集群中任一文档位置，所以可以直接将请求转发到需要的节点上
##5.3.新建、索引和删除单个文档
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/%E6%96%B0%E5%BB%BA%E3%80%81%E7%B4%A2%E5%BC%95%E5%92%8C%E5%88%A0%E9%99%A4%E5%8D%95%E4%B8%AA%E6%96%87%E6%A1%A3.png)
- 客户端向 Node 1 发送新建、索引或者删除请求。 
- 节点使用文档的 _id 确定文档属于分片 0 。请求会被转发到 Node 3，因为分片 0 的主分片目前被分配在 Node 3 上。 
- Node 3 在主分片上面执行请求。如果成功了，它将请求并行转发到 Node 1 和 Node 2 的副本分片上。一旦所有的副本分片都报告成功, Node 3 将向协调节点报告成功，协调节点向客户端报告成功。
##5.4.取回单个文档
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/%E5%8F%96%E5%9B%9E%E5%8D%95%E4%B8%AA%E6%96%87%E6%A1%A3.png)
- 客户端向 Node 1 发送获取请求。
- 节点使用文档的 _id 来确定文档属于分片 0 。分片 0 的副本分片存在于所有的三个节点上。 在这种情况下，它将请求转发到 Node 2 。
- Node 2 将文档返回给 Node 1 ，然后将文档返回给客户端。
##5.5.局部更新文档
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/%E5%B1%80%E9%83%A8%E6%9B%B4%E6%96%B0%E6%96%87%E6%A1%A3.png)
- 客户端向 Node 1 发送更新请求
- 它将请求转发到主分片所在的 Node 3 。 
- Node 3 从主分片检索文档，修改 _source 字段中的 JSON ，并且尝试重新索引主分片的文档。 如果文档已经被另一个进程修改，它会重试步骤 3 ，超过 retry_on_conflict 次后放弃。 
- 如果 Node 3 成功地更新文档，它将新版本的文档并行转发到 Node 1 和 Node 2 上的副本分片，重新建立索引。 一旦所有副本分片都返回成功， Node 3 向协调节点也返回成功，协调节点向客户端返回成功。
##5.6.多文档模式
###5.6.1.使用 mget 取回多个文档
![](https://github.com/HelloWucq/working-knowledge-point/raw/master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87/%E4%BD%BF%E7%94%A8mget%E5%8F%96%E5%9B%9E%E5%A4%9A%E4%B8%AA%E6%96%87%E6%A1%A3.png)
- 客户端向 Node 1 发送 mget 请求。 
- Node 1 为每个分片构建多文档获取请求，然后并行转发这些请求到托管在每个所需的主分片或者副本分片的节点上。一旦收到所有答复， Node 1 构建响应并将其返回给客户端。